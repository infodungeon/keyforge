


~ 
‚ùØ cd Documents/KeyboardLayouts/Data\ Driven\ Analysis/

Documents/KeyboardLayouts/Data Driven Analysis 
‚ùØ ls
cost_matrix.csv  ngrams-all.tsv  scripts  typing_data

Documents/KeyboardLayouts/Data Driven Analysis 
‚ùØ cd scripts

KeyboardLayouts/Data Driven Analysis/scripts via üêç v3.13.7 
‚ùØ ls
__pycache__               analyze_ngrams.py     check_coverage.py                 keyforge
analyze_advanced_flow.py  analyze_trigrams.py   export_symmetric_matrix.py        layout_config.py
analyze_error_causes.py   analyze_weights.py    generate_synthetic_biometrics.py  manage_db.py
analyze_errors.py         analyze_word_flow.py  ingest.py                         scorer.py

KeyboardLayouts/Data Driven Analysis/scripts via üêç v3.13.7 
‚ùØ cd keyforge

keyforge on ÓÇ† master [?] is üì¶ v0.5.0 via ü¶Ä v1.85.0 
‚ùØ ls
Cargo.lock  flamegraph.svg  perf.data.old  target  tmp_poison_test
Cargo.toml  perf.data       src            tests

keyforge on ÓÇ† master [?] is üì¶ v0.5.0 via ü¶Ä v1.85.0 
‚ùØ cat Cargo.toml
[package]
name = "keyforge"
version = "0.5.0"
edition = "2021"

[dependencies]
rayon = "1.8"
fastrand = "2.0"
csv = "1.3"
clap = { version = "4.4", features = ["derive"] }
strum = { version = "0.25", features = ["derive"] }
strum_macros = "0.25"

[profile.release]
opt-level = 3
lto = "fat"
codegen-units = 1
panic = "abort"
strip = true
debug = false

[dev-dependencies]
tempfile = "3.8"
rstest = "0.18"

keyforge on ÓÇ† master [?] is üì¶ v0.5.0 via ü¶Ä v1.85.0 
‚ùØ cd src

keyforge/src on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ ls
config.rs  layouts.rs  lib.rs  main.rs  optimizer  scorer

keyforge/src on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat main.rs
use keyforge::config::Config;
use keyforge::layouts::get_all_layouts;
use keyforge::optimizer::Replica;
use keyforge::scorer::Scorer;
use clap::{Parser, Subcommand, Args};
use rayon::prelude::*;
use std::sync::Arc;
use std::time::{Duration, Instant};

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    #[arg(global = true, short, long, default_value = "../../cost_matrix.csv")]
    cost: String,

    #[arg(global = true, short, long, default_value = "../../ngrams-all.tsv")]
    ngrams: String,

    #[arg(global = true, long, default_value_t = false)]
    debug: bool,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Search(SearchArgs),
    Validate(ValidateArgs),
}

#[derive(Args, Debug)]
struct SearchArgs {
    #[command(flatten)]
    config: Config,

    #[arg(short = 'T', long)]
    time: Option<u64>,

    #[arg(short = 'a', long)]
    attempts: Option<usize>,

    #[arg(short = 'S', long)]
    seed: Option<u64>,
}

#[derive(Args, Debug)]
struct ValidateArgs {
    #[command(flatten)]
    config: Config,

    #[arg(short, long)]
    layout: Option<String>,
}

fn main() {
    let cli = Cli::parse();

    println!("\nüöÄ Initializing KeyForge Core...");
    
    let (config, cmd_result) = match cli.command {
        Commands::Search(args) => (args.config.clone(), Commands::Search(args)),
        Commands::Validate(args) => (args.config.clone(), Commands::Validate(args)),
    };

    if cli.debug {
        println!("   üîß Configuration Loaded:");
        println!("      Epochs: {}", config.search_epochs);
        println!("      SFB Penalty: {:.2}", config.penalty_sfb);
    }

    let scorer = Arc::new(Scorer::new(&cli.cost, &cli.ngrams, config, cli.debug));

    match cmd_result {
        Commands::Search(args) => run_search(args, scorer, cli.debug),
        Commands::Validate(args) => run_validation(args, scorer),
    }
}

fn run_validation(args: ValidateArgs, scorer: Arc<Scorer>) {
    println!("\nüìä === VALIDATION REPORT === üìä");
    println!(
        "{:<14} | {:<8} | {:<8} | {:<8} | {:<19} | {:<26} | {:<8} | {:<8}", 
        "Layout", "THEORY", "Travel", "Effort", "--- PAIN (Geo) ---", "------- FLOW -------", "TIER*", "BAL*"
    );
    println!(
        "{:<14} | {:<8} | {:<8} | {:<8} | {:<5} {:<6} {:<6} | {:<6} {:<6} {:<6} | {:<8} | {:<8}", 
        "", "Total", "Dist", "Finger", "SFB", "Lat", "Scis", "Redir", "Skip", "Roll(-)", "(Info)", "(Info)"
    );
    println!("{:-<125}", "");

    let layouts = get_all_layouts();
    let mut results: Vec<(String, keyforge::scorer::ScoreDetails)> = Vec::new();
    let eval_limit = scorer.config.opt_limit_slow; 

    for (layout_enum, layout_bytes) in layouts {
        if let Some(ref filter) = args.layout {
            if !layout_enum.to_string().to_lowercase().contains(&filter.to_lowercase()) {
                continue;
            }
        }

        let pos_map = keyforge::optimizer::mutation::build_pos_map(&layout_bytes);
        let details = scorer.score_debug(&pos_map, eval_limit);
        results.push((layout_enum.to_string(), details));
    }

    // Sort by Layout Score (Theoretical - Universal Baseline)
    results.sort_by(|a, b| a.1.layout_score.partial_cmp(&b.1.layout_score).unwrap());

    for (name, d) in results {
        println!(
            "{:<14} | {:<8.0} | {:<8.0} | {:<8.0} | {:<5.0} {:<6.0} {:<6.0} | {:<6.0} {:<6.0} {:<6.0} | {:<8.0} | {:<8.0}", 
            name, 
            d.layout_score,
            d.geo_dist,
            d.finger_use,
            d.geo_sfb,
            d.geo_lateral,
            d.geo_scissor,
            d.flow_redirect,
            d.flow_skip,
            d.flow_roll, // Bonus displayed as positive number (it was subtracted in total)
            d.tier_penalty,
            d.imbalance_penalty
        );
    }
    println!("{:-<125}", "");
    println!("* Theory Total = Travel + Effort + Pain + Flow");
    println!("* Tier and Balance are optimization constraints (excluded from Theory score).");
}

fn run_search(args: SearchArgs, scorer: Arc<Scorer>, debug: bool) {
    let num_threads = std::thread::available_parallelism().map(|n| n.get()).unwrap_or(4);
    println!("üî• Spawning {} Replicas for Parallel Tempering", num_threads);

    let min_temp = scorer.config.temp_min;
    let max_temp = scorer.config.temp_max;

    let mut replicas: Vec<Replica> = (0..num_threads)
        .map(|i| {
            let progress = i as f32 / (num_threads - 1) as f32;
            let temp = min_temp * (max_temp / min_temp).powf(progress);
            let replica_seed = args.seed.map(|s| s + i as u64);
            Replica::new(scorer.clone(), temp, replica_seed, debug)
        })
        .collect();

    let mut rng = if let Some(s) = args.seed { fastrand::Rng::with_seed(s + 9999) } else { fastrand::Rng::new() };

    let max_duration = args.time.map(Duration::from_secs);
    let max_attempts = match (args.time, args.attempts) {
        (_, Some(a)) => a,
        (Some(_), None) => usize::MAX,
        (None, None) => 1,
    };

    let total_start_time = Instant::now();
    let mut global_best_score = f32::MAX;
    let mut global_best_layout = String::new();
    let mut attempt_count = 0;

    let target_epochs = scorer.config.search_epochs;
    let target_steps = scorer.config.search_steps;
    let target_patience = scorer.config.search_patience;

    while attempt_count < max_attempts {
        attempt_count += 1;
        if let Some(limit) = max_duration { if total_start_time.elapsed() >= limit { break; } }

        println!("\n‚û°Ô∏è  Attempt #{} (Best: {:.0})", attempt_count, global_best_score);

        // Reset Replicas
        for (i, r) in replicas.iter_mut().enumerate() {
            if let Some(s) = args.seed { r.rng = fastrand::Rng::with_seed(s + (attempt_count as u64 * 100) + i as u64); } 
            else { r.rng = fastrand::Rng::new(); }

            let mut layout;
            let mut pos_map;
            loop {
                layout = keyforge::optimizer::mutation::generate_tiered_layout(&mut r.rng, &scorer.config);
                pos_map = keyforge::optimizer::mutation::build_pos_map(&layout);
                let critical = scorer.config.get_critical_bigrams();
                if !keyforge::optimizer::mutation::fails_sanity(&pos_map, &critical) { break; }
            }
            
            let (base, left, total) = scorer.score_full(&pos_map, scorer.config.opt_limit_fast);
            let mut score = base;
            if total > 0.0 {
                let ratio = left / total;
                let dist = (ratio - 0.5).abs();
                if dist > (scorer.config.max_hand_imbalance - 0.5) { score += dist * scorer.config.penalty_imbalance; }
            }
            r.layout = layout;
            r.pos_map = pos_map;
            r.score = score;
            r.left_load = left;
            r.total_freq = total;
            r.current_limit = scorer.config.opt_limit_fast;
        }

        let mut patience_counter = 0;
        let mut local_best_score = f32::MAX;
        let mut last_print = Instant::now();
        let mut steps_since_last_report = 0;

        for epoch in 0..target_epochs {
            if let Some(limit) = max_duration { if total_start_time.elapsed() >= limit { break; } }

            // --- INTEGRITY CHECK (Debug Mode) ---
            if debug && epoch % 10 == 0 {
                for (i, r) in replicas.iter_mut().enumerate() {
                    let (diff, real) = r.check_integrity();
                    // Allow small floating point drift, but alert on logic errors
                    if diff > 0.1 {
                        println!("‚ö†Ô∏è  DRIFT DETECTED [Replica {}]: Delta {:.2} != Real {:.2} (Diff {:.2})", 
                            i, r.score, real, diff);
                        // Self-heal
                        r.score = real;
                    }
                }
            }
            // ------------------------------------

            let steps_this_epoch: usize = replicas
                .par_iter_mut()
                .map(|r| {
                    let multiplier = if r.temperature > 50.0 { 2.5 } else if r.temperature > 5.0 { 1.5 } else { 1.0 };
                    let adjusted_steps = (target_steps as f32 * multiplier) as usize;
                    r.evolve(adjusted_steps);
                    adjusted_steps
                })
                .sum();

            steps_since_last_report += steps_this_epoch;

            // Replica Swap (Parallel Tempering)
            for i in (0..num_threads - 1).rev() {
                let j = i + 1;
                let e1 = replicas[i].score;
                let e2 = replicas[j].score;
                let t1 = replicas[i].temperature;
                let t2 = replicas[j].temperature;
                let delta_beta = (1.0 / t1) - (1.0 / t2);
                let delta_e = e2 - e1;

                if rng.f32() < (-delta_beta * delta_e).exp() {
                    let temp_layout = replicas[i].layout;
                    let temp_score = replicas[i].score;
                    let temp_pos = replicas[i].pos_map;
                    let temp_load = replicas[i].left_load;

                    replicas[i].layout = replicas[j].layout;
                    replicas[i].score = replicas[j].score;
                    replicas[i].pos_map = replicas[j].pos_map;
                    replicas[i].left_load = replicas[j].left_load;

                    replicas[j].layout = temp_layout;
                    replicas[j].score = temp_score;
                    replicas[j].pos_map = temp_pos;
                    replicas[j].left_load = temp_load;
                }
            }

            let mut improved = false;
            for r in &replicas {
                if r.score < local_best_score - scorer.config.search_patience_threshold {
                    local_best_score = r.score;
                    improved = true;
                }
                if r.score < global_best_score {
                    global_best_score = r.score;
                    global_best_layout = String::from_utf8_lossy(&r.layout).to_string();
                }
            }

            if improved { patience_counter = 0; } else { patience_counter += 1; }
            if patience_counter >= target_patience { println!("   üõë Converged at {:.2}. Restarting...", local_best_score); break; }

            let report_interval = if debug { 10 } else { 50 };
            if epoch % report_interval == 0 && epoch > 0 {
                let now = Instant::now();
                let duration = now.duration_since(last_print).as_secs_f32();
                let ips = (steps_since_last_report as f32) / duration / 1_000_000.0;
                println!("Ep {:5} | Local: {:.0} | Global: {:.0} | {:.2}M/s", epoch, local_best_score, global_best_score, ips);
                last_print = now;
                steps_since_last_report = 0;
            }
        }
    }
    println!("\n=== üèÜ FINAL RESULT ===");
    println!("Score: {:.2}", global_best_score);
    println!("Layout: {}", global_best_layout);
}‚èé                                                                                                                   
keyforge/src on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat config.rs
use clap::Args;

#[derive(Args, Debug, Clone)]
pub struct Config {
    // === SEARCH PARAMETERS ===
    #[arg(long, default_value_t = 10_000)]
    pub search_epochs: usize,

    #[arg(long, default_value_t = 50_000)]
    pub search_steps: usize,

    #[arg(long, default_value_t = 500)]
    pub search_patience: usize,

    #[arg(long, default_value_t = 0.1)]
    pub search_patience_threshold: f32,

    #[arg(long, default_value_t = 0.08)]
    pub temp_min: f32,

    #[arg(long, default_value_t = 1000.0)]
    pub temp_max: f32,

    #[arg(long, default_value_t = 600)]
    pub opt_limit_fast: usize,

    #[arg(long, default_value_t = 3000)]
    pub opt_limit_slow: usize,

    // === BIOMECHANICAL PENALTIES (Multipliers) ===
    #[arg(long, default_value_t = 2.0)]
    pub penalty_sfb: f32,

    #[arg(long, default_value_t = 2.5)]
    pub penalty_scissor: f32,

    #[arg(long, default_value_t = 1.3)]
    pub penalty_ring_pinky: f32,

    #[arg(long, default_value_t = 1.1)]
    pub penalty_lateral: f32,

    // === FLOW COST ADJUSTMENTS (Additive MS) ===
    #[arg(long, default_value_t = 20.0)]
    pub penalty_skip: f32,

    #[arg(long, default_value_t = 15.0)]
    pub penalty_redirect: f32,

    #[arg(long, default_value_t = 5.0)]
    pub penalty_hand_run: f32,

    #[arg(long, default_value_t = 15.0)]
    pub bonus_inward_roll: f32,

    // === TIER PENALTIES (Additive MS) ===
    #[arg(long, default_value_t = 5.0)]
    pub penalty_high_in_med: f32,

    #[arg(long, default_value_t = 20.0)]
    pub penalty_high_in_low: f32,

    #[arg(long, default_value_t = 2.0)]
    pub penalty_med_in_prime: f32,

    #[arg(long, default_value_t = 10.0)]
    pub penalty_med_in_low: f32,

    #[arg(long, default_value_t = 15.0)]
    pub penalty_low_in_prime: f32,

    #[arg(long, default_value_t = 2.0)]
    pub penalty_low_in_med: f32,

    // === HAND BALANCE ===
    #[arg(long, default_value_t = 200.0)]
    pub penalty_imbalance: f32,

    #[arg(long, default_value_t = 0.55)]
    pub max_hand_imbalance: f32,

    // === SCORING WEIGHTS ===
    #[arg(long, default_value_t = 10.0)] // Base distance weight
    pub weight_geo_dist: f32,

    #[arg(long, default_value_t = 45.0)] // Finger effort weight (Stronger than distance)
    pub weight_finger_effort: f32,

    // === DEFINITIONS ===
    #[arg(long, default_value = "etaoinshr")]
    pub tier_high_chars: String,

    #[arg(long, default_value = "ldcumwfgypb.,")]
    pub tier_med_chars: String,

    #[arg(long, default_value = "vkjxqz/;")]
    pub tier_low_chars: String,

    #[arg(long, default_value = "th,he,in,er,an,re,nd,ou")]
    pub critical_bigrams: String,

    #[arg(long, default_value = "0.0,1.0,1.1,1.3,1.6")]
    pub finger_penalty_scale: String,

    #[arg(long, default_value = "1.0,1.0,1.0,1.2,1.5")]
    pub finger_repeat_scale: String,

    #[arg(long, default_value_t = 200_000_000.0)]
    pub corpus_scale: f32,

    #[arg(long, default_value_t = 120.0)]
    pub default_cost_ms: f32,
}

impl Config {
    pub fn get_finger_penalty_scale(&self) -> [f32; 5] {
        parse_f32_array::<5>(&self.finger_penalty_scale, "finger_penalty_scale")
    }
    pub fn get_finger_repeat_scale(&self) -> [f32; 5] {
        parse_f32_array::<5>(&self.finger_repeat_scale, "finger_repeat_scale")
    }
    pub fn get_critical_bigrams(&self) -> Vec<[u8; 2]> {
        self.critical_bigrams
            .split(',')
            .map(|s| {
                let b = s.trim().as_bytes();
                if b.len() != 2 {
                    panic!("Critical bigram '{}' is not 2 chars", s);
                }
                [b[0], b[1]]
            })
            .collect()
    }
}

fn parse_f32_array<const N: usize>(s: &str, name: &str) -> [f32; N] {
    let parts: Vec<&str> = s.split(',').collect();
    if parts.len() != N {
        panic!("--{} requires {} values", name, N);
    }
    let mut arr = [0.0; N];
    for (i, p) in parts.iter().enumerate() {
        arr[i] = p
            .trim()
            .parse()
            .unwrap_or_else(|_| panic!("Invalid number in {}", name));
    }
    arr
}

// --- HARDWARE SLOT DEFINITIONS ---
// Prime: Home Row
pub const SLOTS_PRIME: &[usize] = &[10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
// Med: Top Row
pub const SLOTS_MED: &[usize] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// Low: Bottom Row
pub const SLOTS_LOW: &[usize] = &[20, 21, 22, 23, 24, 25, 26, 27, 28, 29];

#[derive(Debug, Clone, Copy)]
pub struct KeyInfo {
    pub hand: u8,
    pub finger: u8,
    pub row: i8,
    pub col: i8,
    pub is_stretch: bool,
}

pub const KEY_DEFS: [KeyInfo; 30] = [
    // ROW 0 (Top)
    KeyInfo {
        hand: 0,
        finger: 4,
        row: 0,
        col: 0,
        is_stretch: false,
    }, // 0 Q
    KeyInfo {
        hand: 0,
        finger: 3,
        row: 0,
        col: 1,
        is_stretch: false,
    }, // 1 W
    KeyInfo {
        hand: 0,
        finger: 2,
        row: 0,
        col: 2,
        is_stretch: false,
    }, // 2 E
    KeyInfo {
        hand: 0,
        finger: 1,
        row: 0,
        col: 3,
        is_stretch: false,
    }, // 3 R
    KeyInfo {
        hand: 0,
        finger: 1,
        row: 0,
        col: 4,
        is_stretch: true,
    }, // 4 T
    KeyInfo {
        hand: 1,
        finger: 1,
        row: 0,
        col: 5,
        is_stretch: true,
    }, // 5 Y
    KeyInfo {
        hand: 1,
        finger: 1,
        row: 0,
        col: 6,
        is_stretch: false,
    }, // 6 U
    KeyInfo {
        hand: 1,
        finger: 2,
        row: 0,
        col: 7,
        is_stretch: false,
    }, // 7 I
    KeyInfo {
        hand: 1,
        finger: 3,
        row: 0,
        col: 8,
        is_stretch: false,
    }, // 8 O
    KeyInfo {
        hand: 1,
        finger: 4,
        row: 0,
        col: 9,
        is_stretch: false,
    }, // 9 P
    // ROW 1 (Home)
    KeyInfo {
        hand: 0,
        finger: 4,
        row: 1,
        col: 0,
        is_stretch: false,
    }, // 10 A
    KeyInfo {
        hand: 0,
        finger: 3,
        row: 1,
        col: 1,
        is_stretch: false,
    }, // 11 S
    KeyInfo {
        hand: 0,
        finger: 2,
        row: 1,
        col: 2,
        is_stretch: false,
    }, // 12 D
    KeyInfo {
        hand: 0,
        finger: 1,
        row: 1,
        col: 3,
        is_stretch: false,
    }, // 13 F
    KeyInfo {
        hand: 0,
        finger: 1,
        row: 1,
        col: 4,
        is_stretch: true,
    }, // 14 G
    KeyInfo {
        hand: 1,
        finger: 1,
        row: 1,
        col: 5,
        is_stretch: true,
    }, // 15 H
    KeyInfo {
        hand: 1,
        finger: 1,
        row: 1,
        col: 6,
        is_stretch: false,
    }, // 16 J
    KeyInfo {
        hand: 1,
        finger: 2,
        row: 1,
        col: 7,
        is_stretch: false,
    }, // 17 K
    KeyInfo {
        hand: 1,
        finger: 3,
        row: 1,
        col: 8,
        is_stretch: false,
    }, // 18 L
    KeyInfo {
        hand: 1,
        finger: 4,
        row: 1,
        col: 9,
        is_stretch: false,
    }, // 19 ;
    // ROW 2 (Bottom)
    KeyInfo {
        hand: 0,
        finger: 4,
        row: 2,
        col: 0,
        is_stretch: false,
    }, // 20 Z
    KeyInfo {
        hand: 0,
        finger: 3,
        row: 2,
        col: 1,
        is_stretch: false,
    }, // 21 X
    KeyInfo {
        hand: 0,
        finger: 2,
        row: 2,
        col: 2,
        is_stretch: false,
    }, // 22 C
    KeyInfo {
        hand: 0,
        finger: 1,
        row: 2,
        col: 3,
        is_stretch: false,
    }, // 23 V
    KeyInfo {
        hand: 0,
        finger: 1,
        row: 2,
        col: 4,
        is_stretch: true,
    }, // 24 B
    KeyInfo {
        hand: 1,
        finger: 1,
        row: 2,
        col: 5,
        is_stretch: true,
    }, // 25 N
    KeyInfo {
        hand: 1,
        finger: 1,
        row: 2,
        col: 6,
        is_stretch: false,
    }, // 26 M
    KeyInfo {
        hand: 1,
        finger: 2,
        row: 2,
        col: 7,
        is_stretch: false,
    }, // 27 ,
    KeyInfo {
        hand: 1,
        finger: 3,
        row: 2,
        col: 8,
        is_stretch: false,
    }, // 28 .
    KeyInfo {
        hand: 1,
        finger: 4,
        row: 2,
        col: 9,
        is_stretch: false,
    }, // 29 /
];

keyforge/src on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat layouts.rs 
use std::collections::HashMap;
use strum::IntoEnumIterator;
use strum_macros::{Display, EnumIter, EnumString};

#[derive(Debug, Clone, Copy, EnumIter, EnumString, Display, PartialEq, Eq, Hash)]
#[strum(serialize_all = "snake_case")]
pub enum KnownLayout {
    Qwerty,
    Colemak,
    ColemakDH,
    Canary,
    Dvorak,
    HandsDownNeu,
    Sturdy,
    Focal,
    Graphite,
    Gallium,
    Engram,
    Workman,
}

impl KnownLayout {
    // Maps standard 30-key row-stagger.
    // 0-9: Q..P
    // 10-19: A..;
    // 20-29: Z../
    pub fn get_str(&self) -> &'static str {
        match self {
            Self::Qwerty => "qwertyuiopasdfghjkl;zxcvbnm,./",
            Self::Dvorak => "',.pyfgcrlaoeuidhtns;qjkxbmwvz",
            Self::Colemak => "qwfpgjluy;arstdhneiozxcvbkm,./",
            Self::ColemakDH => "qwfpbjluy;arstgmneiozxccdkv,./",
            Self::Workman => "qdrwbjfup;ashtgyneoizxmcvkl,./",
            // CORRECTED STRINGS:
            // Canary: E is Right Middle (17), not Pinky (19)
            Self::Canary => "wlypkzfou;crstgmneiaqjvdkhx,./",

            // Sturdy: V M L H K ...
            Self::Sturdy => "vmlhkqjou;strygfaeibxcdwnzp,./",

            Self::HandsDownNeu => "xrybpjlcu;snhtgmoeaizwvdkqf,./",
            Self::Focal => "wlypkvzou;rsntghjaeiqxcbdmf,./",
            Self::Graphite => "bldwzxuou;nrtsgyhaieqjmkcpv,./",
            Self::Gallium => "bldcvjgou;nrstymhaiezqxwkfp,./",
            Self::Engram => "byou'ldwvpciea,htsnqjxkrmgzf.;",
        }
    }

    pub fn to_bytes(&self) -> [u8; 30] {
        let s = self.get_str();
        let mut bytes = [0u8; 30];
        for (i, b) in s.bytes().enumerate() {
            if i < 30 {
                bytes[i] = b;
            }
        }
        bytes
    }
}

pub fn get_all_layouts() -> HashMap<KnownLayout, [u8; 30]> {
    let mut map = HashMap::new();
    for layout in KnownLayout::iter() {
        map.insert(layout, layout.to_bytes());
    }
    map
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_layout_integrity() {
        for layout in KnownLayout::iter() {
            let s = layout.get_str();
            // Allow space for unused keys if layout definition is sparse,
            // but generally we expect 30 chars for the standard grid.
            // Some strings might use spaces for unassigned keys.
            assert_eq!(
                s.len(),
                30,
                "Layout {:?} length is {} (Expected 30)",
                layout,
                s.len()
            );
        }
    }
}

keyforge/src on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat layouts.rs 
use std::collections::HashMap;
use strum::IntoEnumIterator;
use strum_macros::{Display, EnumIter, EnumString};

#[derive(Debug, Clone, Copy, EnumIter, EnumString, Display, PartialEq, Eq, Hash)]
#[strum(serialize_all = "snake_case")]
pub enum KnownLayout {
    Qwerty,
    Colemak,
    ColemakDH,
    Canary,
    Dvorak,
    HandsDownNeu,
    Sturdy,
    Focal,
    Graphite,
    Gallium,
    Engram,
    Workman,
}

impl KnownLayout {
    // Maps standard 30-key row-stagger.
    // 0-9: Q..P
    // 10-19: A..;
    // 20-29: Z../
    pub fn get_str(&self) -> &'static str {
        match self {
            Self::Qwerty => "qwertyuiopasdfghjkl;zxcvbnm,./",
            Self::Dvorak => "',.pyfgcrlaoeuidhtns;qjkxbmwvz",
            Self::Colemak => "qwfpgjluy;arstdhneiozxcvbkm,./",
            Self::ColemakDH => "qwfpbjluy;arstgmneiozxccdkv,./",
            Self::Workman => "qdrwbjfup;ashtgyneoizxmcvkl,./",
            // CORRECTED STRINGS:
            // Canary: E is Right Middle (17), not Pinky (19)
            Self::Canary => "wlypkzfou;crstgmneiaqjvdkhx,./",

            // Sturdy: V M L H K ...
            Self::Sturdy => "vmlhkqjou;strygfaeibxcdwnzp,./",

            Self::HandsDownNeu => "xrybpjlcu;snhtgmoeaizwvdkqf,./",
            Self::Focal => "wlypkvzou;rsntghjaeiqxcbdmf,./",
            Self::Graphite => "bldwzxuou;nrtsgyhaieqjmkcpv,./",
            Self::Gallium => "bldcvjgou;nrstymhaiezqxwkfp,./",
            Self::Engram => "byou'ldwvpciea,htsnqjxkrmgzf.;",
        }
    }

    pub fn to_bytes(&self) -> [u8; 30] {
        let s = self.get_str();
        let mut bytes = [0u8; 30];
        for (i, b) in s.bytes().enumerate() {
            if i < 30 {
                bytes[i] = b;
            }
        }
        bytes
    }
}

pub fn get_all_layouts() -> HashMap<KnownLayout, [u8; 30]> {
    let mut map = HashMap::new();
    for layout in KnownLayout::iter() {
        map.insert(layout, layout.to_bytes());
    }
    map
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_layout_integrity() {
        for layout in KnownLayout::iter() {
            let s = layout.get_str();
            // Allow space for unused keys if layout definition is sparse,
            // but generally we expect 30 chars for the standard grid.
            // Some strings might use spaces for unassigned keys.
            assert_eq!(
                s.len(),
                30,
                "Layout {:?} length is {} (Expected 30)",
                layout,
                s.len()
            );
        }
    }
}

keyforge/src on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cd scorer

keyforge/src/scorer on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ ls
engine.rs  loader.rs  mod.rs  physics.rs  setup.rs  types.rs

keyforge/src/scorer on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat engine.rs
use super::physics::{analyze_bigram, get_geo_dist, get_reach_cost};
use super::{ScoreDetails, Scorer};
use crate::config::KEY_DEFS;

/// Fast Path: Used by the Optimizer.
/// Relies on pre-calculated tables (full_cost_matrix, slot_monogram_costs) for maximum speed.
pub fn score_full(scorer: &Scorer, pos_map: &[u8; 256], limit: usize) -> (f32, f32, f32) {
    let mut score = 0.0;
    let mut left_load = 0.0;
    let mut total_freq = 0.0;

    // 1. Chars (Reach + Effort + Tier)
    // Uses pre-calculated slot_monogram_costs
    for i in 0..256 {
        let freq = scorer.char_freqs[i];
        if freq > 0.0 {
            let p = pos_map[i];
            if p != 255 {
                total_freq += freq;
                if KEY_DEFS[p as usize].hand == 0 {
                    left_load += freq;
                }

                score += scorer.tier_penalty_matrix[scorer.char_tier_map[i] as usize]
                    [scorer.slot_tier_map[p as usize] as usize]
                    * freq;
                score += scorer.slot_monogram_costs[p as usize] * freq;
            }
        }
    }

    // 2. Bigrams (User Matrix + Penalties)
    // Uses pre-baked full_cost_matrix
    for c1 in 0..256 {
        let p1 = pos_map[c1];
        if p1 == 255 {
            continue;
        }
        let start = scorer.bigram_starts[c1];
        let end = scorer.bigram_starts[c1 + 1];
        for k in start..end {
            if scorer.bigrams_self_first[k] {
                let c2 = scorer.bigrams_others[k] as usize;
                let p2 = pos_map[c2];
                if p2 != 255 {
                    score +=
                        scorer.full_cost_matrix[p1 as usize][p2 as usize] * scorer.bigrams_freqs[k];
                }
            }
        }
    }

    // 3. Trigrams (Flow)
    for c1 in 0..256 {
        let p1 = pos_map[c1];
        if p1 == 255 {
            continue;
        }
        let start = scorer.trigram_starts[c1];
        let end = scorer.trigram_starts[c1 + 1];
        let effective_end = if limit > 0 && (end - start) > limit {
            start + limit
        } else {
            end
        };
        for k in start..effective_end {
            let t = &scorer.trigrams_flat[k];
            if t.role == 0 {
                let c2 = t.other1 as usize;
                let c3 = t.other2 as usize;
                let p2 = pos_map[c2];
                let p3 = pos_map[c3];
                if p2 != 255 && p3 != 255 {
                    let idx = (p1 as usize) * 900 + (p2 as usize) * 30 + (p3 as usize);
                    let cost = scorer.trigram_cost_table[idx];
                    if cost != 0.0 {
                        score += cost * t.freq;
                    }
                }
            }
        }
    }

    // Note: Imbalance is calculated by the caller (Replica) to allow incremental updates.
    (score, left_load, total_freq)
}

/// Detailed Path: Used by Validation.
/// Re-calculates physics on the fly to populate specific report buckets.
pub fn score_debug(scorer: &Scorer, pos_map: &[u8; 256], limit: usize) -> ScoreDetails {
    let mut d = ScoreDetails::default();
    let mut total_freq = 0.0;
    let mut left_load = 0.0;

    // 1. CHARS (Reach + Effort + Tier)
    for i in 0..256 {
        let freq = scorer.char_freqs[i];
        if freq > 0.0 {
            let p = pos_map[i];
            if p != 255 {
                total_freq += freq;
                let info = &KEY_DEFS[p as usize];
                if info.hand == 0 {
                    left_load += freq;
                }

                d.tier_penalty += scorer.tier_penalty_matrix[scorer.char_tier_map[i] as usize]
                    [scorer.slot_tier_map[p as usize] as usize]
                    * freq;

                // Effort
                d.finger_use += (scorer.finger_scales[info.finger as usize]
                    * scorer.config.weight_finger_effort)
                    * freq;

                // Reach (Base Travel)
                d.geo_dist += get_reach_cost(p as usize, scorer.config.weight_geo_dist) * freq;
            }
        }
    }

    // 2. BIGRAMS (User Dist + Geo Penalties + Jumps)
    for c1 in 0..256 {
        let p1 = pos_map[c1];
        if p1 == 255 {
            continue;
        }
        let start = scorer.bigram_starts[c1];
        let end = scorer.bigram_starts[c1 + 1];
        for k in start..end {
            if scorer.bigrams_self_first[k] {
                let c2 = scorer.bigrams_others[k] as usize;
                let p2 = pos_map[c2];
                if p2 != 255 {
                    let freq = scorer.bigrams_freqs[k];

                    // User Distance (Raw from CSV)
                    d.user_dist += scorer.raw_user_matrix[p1 as usize][p2 as usize] * freq;

                    // Physics Analysis
                    let mechanics = analyze_bigram(p1 as usize, p2 as usize);

                    if mechanics.is_same_hand {
                        // Distance & Multiplier Logic
                        let mut mult = 0.0;
                        let dist =
                            get_geo_dist(p1 as usize, p2 as usize, scorer.config.weight_geo_dist);

                        if mechanics.is_sfb {
                            // SFB: Adds physical travel (Jump) AND penalty
                            d.geo_dist += dist * freq;
                            d.geo_sfb += (dist * (scorer.config.penalty_sfb - 1.0)) * freq;
                            mult = scorer.config.penalty_sfb - 1.0;
                            d.user_penalty_sfb +=
                                (scorer.raw_user_matrix[p1 as usize][p2 as usize] * mult) * freq;
                        } else {
                            // Non-SFB: Adds penalty based on difficulty, but NO physical travel added
                            if mechanics.is_scissor {
                                mult = scorer.config.penalty_scissor - 1.0;
                                d.geo_scissor += (dist * mult) * freq;
                                d.user_penalty_scis +=
                                    (scorer.raw_user_matrix[p1 as usize][p2 as usize] * mult)
                                        * freq;
                            } else if mechanics.is_ring_pinky || mechanics.is_lateral {
                                let pen = if mechanics.is_ring_pinky {
                                    scorer.config.penalty_ring_pinky
                                } else {
                                    scorer.config.penalty_lateral
                                };
                                mult = pen - 1.0;
                                d.geo_lateral += (dist * mult) * freq;
                                d.user_penalty_lat +=
                                    (scorer.raw_user_matrix[p1 as usize][p2 as usize] * mult)
                                        * freq;
                            }
                        }

                        if mult > 0.0 {
                            d.penalty_geo += (dist * mult) * freq;
                            d.penalty_user +=
                                (scorer.raw_user_matrix[p1 as usize][p2 as usize] * mult) * freq;
                        }
                    }
                }
            }
        }
    }

    // 3. TRIGRAMS (Flow)
    for c1 in 0..256 {
        let p1 = pos_map[c1];
        if p1 == 255 {
            continue;
        }
        let start = scorer.trigram_starts[c1];
        let end = scorer.trigram_starts[c1 + 1];
        let effective_end = if limit > 0 && (end - start) > limit {
            start + limit
        } else {
            end
        };
        for k in start..effective_end {
            let t = &scorer.trigrams_flat[k];
            if t.role == 0 {
                let c2 = t.other1 as usize;
                let c3 = t.other2 as usize;
                let p2 = pos_map[c2];
                let p3 = pos_map[c3];
                if p2 != 255 && p3 != 255 {
                    let idx = (p1 as usize) * 900 + (p2 as usize) * 30 + (p3 as usize);
                    let cost = scorer.trigram_cost_table[idx];
                    if cost != 0.0 {
                        d.flow_cost += cost * t.freq;

                        // Deconstruct cost for reporting (Simplified check to categorize)
                        let k1 = &KEY_DEFS[p1 as usize];
                        let k2 = &KEY_DEFS[p2 as usize];
                        let k3 = &KEY_DEFS[p3 as usize];

                        if k1.hand == k2.hand && k2.hand == k3.hand {
                            let f1 = k1.finger as i8;
                            let f2 = k2.finger as i8;
                            let f3 = k3.finger as i8;
                            let dir1 = f2 - f1;
                            let dir2 = f3 - f2;

                            if f1 == f3 && f1 != f2 {
                                d.flow_skip += scorer.config.penalty_skip * t.freq;
                            } else if dir1 != 0 && dir2 != 0 && dir1.signum() != dir2.signum() {
                                d.flow_redirect += scorer.config.penalty_redirect * t.freq;
                            } else if dir1 < 0 && dir2 < 0 {
                                d.flow_roll += scorer.config.bonus_inward_roll * t.freq;
                            }
                            // Note: HandRun isn't explicitly broken out here but is in flow_cost
                        }
                    }
                }
            }
        }
    }

    // 4. IMBALANCE
    if total_freq > 0.0 {
        let ratio = left_load / total_freq;
        let dist = (ratio - 0.5).abs();
        if dist > (scorer.config.max_hand_imbalance - 0.5) {
            d.imbalance_penalty = dist * scorer.config.penalty_imbalance;
        }
    }

    d.layout_score = d.geo_dist
        + d.finger_use
        + d.penalty_geo
        + d.flow_cost
        + d.tier_penalty
        + d.imbalance_penalty;
    d.user_score = d.user_dist
        + d.finger_use
        + d.penalty_user
        + d.flow_cost
        + d.tier_penalty
        + d.imbalance_penalty;

    d
}


keyforge/src/scorer on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat engine.rs
use super::physics::{analyze_bigram, get_geo_dist, get_reach_cost};
use super::{ScoreDetails, Scorer};
use crate::config::KEY_DEFS;

/// Fast Path: Used by the Optimizer.
/// Relies on pre-calculated tables (full_cost_matrix, slot_monogram_costs) for maximum speed.
pub fn score_full(scorer: &Scorer, pos_map: &[u8; 256], limit: usize) -> (f32, f32, f32) {
    let mut score = 0.0;
    let mut left_load = 0.0;
    let mut total_freq = 0.0;

    // 1. Chars (Reach + Effort + Tier)
    // Uses pre-calculated slot_monogram_costs
    for i in 0..256 {
        let freq = scorer.char_freqs[i];
        if freq > 0.0 {
            let p = pos_map[i];
            if p != 255 {
                total_freq += freq;
                if KEY_DEFS[p as usize].hand == 0 {
                    left_load += freq;
                }

                score += scorer.tier_penalty_matrix[scorer.char_tier_map[i] as usize]
                    [scorer.slot_tier_map[p as usize] as usize]
                    * freq;
                score += scorer.slot_monogram_costs[p as usize] * freq;
            }
        }
    }

    // 2. Bigrams (User Matrix + Penalties)
    // Uses pre-baked full_cost_matrix
    for c1 in 0..256 {
        let p1 = pos_map[c1];
        if p1 == 255 {
            continue;
        }
        let start = scorer.bigram_starts[c1];
        let end = scorer.bigram_starts[c1 + 1];
        for k in start..end {
            if scorer.bigrams_self_first[k] {
                let c2 = scorer.bigrams_others[k] as usize;
                let p2 = pos_map[c2];
                if p2 != 255 {
                    score +=
                        scorer.full_cost_matrix[p1 as usize][p2 as usize] * scorer.bigrams_freqs[k];
                }
            }
        }
    }

    // 3. Trigrams (Flow)
    for c1 in 0..256 {
        let p1 = pos_map[c1];
        if p1 == 255 {
            continue;
        }
        let start = scorer.trigram_starts[c1];
        let end = scorer.trigram_starts[c1 + 1];
        let effective_end = if limit > 0 && (end - start) > limit {
            start + limit
        } else {
            end
        };
        for k in start..effective_end {
            let t = &scorer.trigrams_flat[k];
            if t.role == 0 {
                let c2 = t.other1 as usize;
                let c3 = t.other2 as usize;
                let p2 = pos_map[c2];
                let p3 = pos_map[c3];
                if p2 != 255 && p3 != 255 {
                    let idx = (p1 as usize) * 900 + (p2 as usize) * 30 + (p3 as usize);
                    let cost = scorer.trigram_cost_table[idx];
                    if cost != 0.0 {
                        score += cost * t.freq;
                    }
                }
            }
        }
    }

    // Note: Imbalance is calculated by the caller (Replica) to allow incremental updates.
    (score, left_load, total_freq)
}

/// Detailed Path: Used by Validation.
/// Re-calculates physics on the fly to populate specific report buckets.
pub fn score_debug(scorer: &Scorer, pos_map: &[u8; 256], limit: usize) -> ScoreDetails {
    let mut d = ScoreDetails::default();
    let mut total_freq = 0.0;
    let mut left_load = 0.0;

    // 1. CHARS (Reach + Effort + Tier)
    for i in 0..256 {
        let freq = scorer.char_freqs[i];
        if freq > 0.0 {
            let p = pos_map[i];
            if p != 255 {
                total_freq += freq;
                let info = &KEY_DEFS[p as usize];
                if info.hand == 0 {
                    left_load += freq;
                }

                d.tier_penalty += scorer.tier_penalty_matrix[scorer.char_tier_map[i] as usize]
                    [scorer.slot_tier_map[p as usize] as usize]
                    * freq;

                // Effort
                d.finger_use += (scorer.finger_scales[info.finger as usize]
                    * scorer.config.weight_finger_effort)
                    * freq;

                // Reach (Base Travel)
                d.geo_dist += get_reach_cost(p as usize, scorer.config.weight_geo_dist) * freq;
            }
        }
    }

    // 2. BIGRAMS (User Dist + Geo Penalties + Jumps)
    for c1 in 0..256 {
        let p1 = pos_map[c1];
        if p1 == 255 {
            continue;
        }
        let start = scorer.bigram_starts[c1];
        let end = scorer.bigram_starts[c1 + 1];
        for k in start..end {
            if scorer.bigrams_self_first[k] {
                let c2 = scorer.bigrams_others[k] as usize;
                let p2 = pos_map[c2];
                if p2 != 255 {
                    let freq = scorer.bigrams_freqs[k];

                    // User Distance (Raw from CSV)
                    d.user_dist += scorer.raw_user_matrix[p1 as usize][p2 as usize] * freq;

                    // Physics Analysis
                    let mechanics = analyze_bigram(p1 as usize, p2 as usize);

                    if mechanics.is_same_hand {
                        // Distance & Multiplier Logic
                        let mut mult = 0.0;
                        let dist =
                            get_geo_dist(p1 as usize, p2 as usize, scorer.config.weight_geo_dist);

                        if mechanics.is_sfb {
                            // SFB: Adds physical travel (Jump) AND penalty
                            d.geo_dist += dist * freq;
                            d.geo_sfb += (dist * (scorer.config.penalty_sfb - 1.0)) * freq;
                            mult = scorer.config.penalty_sfb - 1.0;
                            d.user_penalty_sfb +=
                                (scorer.raw_user_matrix[p1 as usize][p2 as usize] * mult) * freq;
                        } else {
                            // Non-SFB: Adds penalty based on difficulty, but NO physical travel added
                            if mechanics.is_scissor {
                                mult = scorer.config.penalty_scissor - 1.0;
                                d.geo_scissor += (dist * mult) * freq;
                                d.user_penalty_scis +=
                                    (scorer.raw_user_matrix[p1 as usize][p2 as usize] * mult)
                                        * freq;
                            } else if mechanics.is_ring_pinky || mechanics.is_lateral {
                                let pen = if mechanics.is_ring_pinky {
                                    scorer.config.penalty_ring_pinky
                                } else {
                                    scorer.config.penalty_lateral
                                };
                                mult = pen - 1.0;
                                d.geo_lateral += (dist * mult) * freq;
                                d.user_penalty_lat +=
                                    (scorer.raw_user_matrix[p1 as usize][p2 as usize] * mult)
                                        * freq;
                            }
                        }

                        if mult > 0.0 {
                            d.penalty_geo += (dist * mult) * freq;
                            d.penalty_user +=
                                (scorer.raw_user_matrix[p1 as usize][p2 as usize] * mult) * freq;
                        }
                    }
                }
            }
        }
    }

    // 3. TRIGRAMS (Flow)
    for c1 in 0..256 {
        let p1 = pos_map[c1];
        if p1 == 255 {
            continue;
        }
        let start = scorer.trigram_starts[c1];
        let end = scorer.trigram_starts[c1 + 1];
        let effective_end = if limit > 0 && (end - start) > limit {
            start + limit
        } else {
            end
        };
        for k in start..effective_end {
            let t = &scorer.trigrams_flat[k];
            if t.role == 0 {
                let c2 = t.other1 as usize;
                let c3 = t.other2 as usize;
                let p2 = pos_map[c2];
                let p3 = pos_map[c3];
                if p2 != 255 && p3 != 255 {
                    let idx = (p1 as usize) * 900 + (p2 as usize) * 30 + (p3 as usize);
                    let cost = scorer.trigram_cost_table[idx];
                    if cost != 0.0 {
                        d.flow_cost += cost * t.freq;

                        // Deconstruct cost for reporting (Simplified check to categorize)
                        let k1 = &KEY_DEFS[p1 as usize];
                        let k2 = &KEY_DEFS[p2 as usize];
                        let k3 = &KEY_DEFS[p3 as usize];

                        if k1.hand == k2.hand && k2.hand == k3.hand {
                            let f1 = k1.finger as i8;
                            let f2 = k2.finger as i8;
                            let f3 = k3.finger as i8;
                            let dir1 = f2 - f1;
                            let dir2 = f3 - f2;

                            if f1 == f3 && f1 != f2 {
                                d.flow_skip += scorer.config.penalty_skip * t.freq;
                            } else if dir1 != 0 && dir2 != 0 && dir1.signum() != dir2.signum() {
                                d.flow_redirect += scorer.config.penalty_redirect * t.freq;
                            } else if dir1 < 0 && dir2 < 0 {
                                d.flow_roll += scorer.config.bonus_inward_roll * t.freq;
                            }
                            // Note: HandRun isn't explicitly broken out here but is in flow_cost
                        }
                    }
                }
            }
        }
    }

    // 4. IMBALANCE
    if total_freq > 0.0 {
        let ratio = left_load / total_freq;
        let dist = (ratio - 0.5).abs();
        if dist > (scorer.config.max_hand_imbalance - 0.5) {
            d.imbalance_penalty = dist * scorer.config.penalty_imbalance;
        }
    }

    d.layout_score = d.geo_dist
        + d.finger_use
        + d.penalty_geo
        + d.flow_cost
        + d.tier_penalty
        + d.imbalance_penalty;
    d.user_score = d.user_dist
        + d.finger_use
        + d.penalty_user
        + d.flow_cost
        + d.tier_penalty
        + d.imbalance_penalty;

    d
}


keyforge/src/scorer on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat mod.rs
pub mod engine;
pub mod loader;
pub mod physics;
pub mod setup;
pub mod types;

use self::loader::TrigramRef;
pub use self::types::ScoreDetails;
use crate::config::Config;

pub struct Scorer {
    pub config: Config,
    pub tier_penalty_matrix: [[f32; 3]; 3],

    // --- Data Tables (Fast Lookups) ---
    // User Data + Penalties (Used by Optimizer)
    pub full_cost_matrix: [[f32; 30]; 30],
    // Pure User Data (Used by Validator/Report)
    pub raw_user_matrix: [[f32; 30]; 30],

    pub trigram_cost_table: Vec<f32>,
    pub slot_monogram_costs: [f32; 30],
    pub finger_scales: [f32; 5],

    // --- N-Gram Data (CSR Format) ---
    pub bigram_starts: Vec<usize>,
    pub bigrams_others: Vec<u8>,
    pub bigrams_freqs: Vec<f32>,
    pub bigrams_self_first: Vec<bool>,

    pub trigram_starts: Vec<usize>,
    pub trigrams_flat: Vec<TrigramRef>,

    pub char_freqs: [f32; 256],

    // --- Mappings ---
    pub char_tier_map: [u8; 256],
    pub slot_tier_map: [u8; 30],
    pub critical_mask: [bool; 256],
    pub freq_matrix: [[f32; 256]; 256],
}

impl Scorer {
    pub fn new(cost_path: &str, ngrams_path: &str, config: Config, debug: bool) -> Self {
        setup::build_scorer(cost_path, ngrams_path, config, debug)
    }

    /// Optimized scoring for the search loop (Fast)
    pub fn score_full(&self, pos_map: &[u8; 256], limit: usize) -> (f32, f32, f32) {
        engine::score_full(self, pos_map, limit)
    }

    /// Detailed scoring for the validation report (Rich Data)
    pub fn score_debug(&self, pos_map: &[u8; 256], limit: usize) -> ScoreDetails {
        engine::score_debug(self, pos_map, limit)
    }
}

keyforge/src/scorer on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat physics.rs 
use crate::config::KEY_DEFS;

/// Result of analyzing two keys for physical difficulty
#[derive(Debug, Default, PartialEq)]
pub struct BigramAnalysis {
    pub is_same_hand: bool,
    pub is_sfb: bool,
    pub is_scissor: bool,
    pub is_ring_pinky: bool,
    pub is_lateral: bool,
}

/// Calculates pure Euclidean distance between two keys.
pub fn get_geo_dist(i: usize, j: usize, scale: f32) -> f32 {
    if i == j {
        return 0.0;
    }
    let k1 = &KEY_DEFS[i];
    let k2 = &KEY_DEFS[j];

    if k1.hand != k2.hand {
        return 0.0;
    }

    let dx = (k1.col as f32 - k2.col as f32).abs();
    let dy = (k1.row as f32 - k2.row as f32).abs();

    (dx * dx + dy * dy).sqrt() * scale
}

/// Calculates distance from Home Position (Reach).
pub fn get_reach_cost(i: usize, scale: f32) -> f32 {
    let ki = &KEY_DEFS[i];
    // Home Row is defined as 1
    let dy = (ki.row - 1).abs() as f32;

    let mut dx = 0.0;
    if ki.finger == 1 {
        // Index lateral reach logic
        if ki.hand == 0 && ki.col == 4 {
            dx = 1.0;
        }
        if ki.hand == 1 && ki.col == 5 {
            dx = 1.0;
        }
    }

    let dist = (dx * dx + dy * dy).sqrt();
    dist * scale
}

/// Analyzes the mechanical relationship between two keys
pub fn analyze_bigram(i: usize, j: usize) -> BigramAnalysis {
    let k1 = &KEY_DEFS[i];
    let k2 = &KEY_DEFS[j];
    let mut res = BigramAnalysis::default();

    if k1.hand != k2.hand {
        return res;
    }
    res.is_same_hand = true;

    // 1. Check SFB (Same Finger) - Independent Check
    if k1.finger == k2.finger && i != j {
        res.is_sfb = true;
    }

    // 2. Check Lateral - Independent Check
    // Defined as: Same Row, Adjacent Columns, involving a Stretch Column
    if k1.row == k2.row && (k1.col - k2.col).abs() == 1 {
        if k1.is_stretch || k2.is_stretch {
            res.is_lateral = true;
        }
    }

    // 3. Check Scissor & Ring/Pinky (Only applies if fingers differ)
    if k1.finger != k2.finger {
        // Scissor: Adjacent fingers, >=2 row difference
        if (k1.finger as i8 - k2.finger as i8).abs() == 1 && (k1.row - k2.row).abs() >= 2 {
            res.is_scissor = true;
        }
        // Ring/Pinky Twist
        else if (k1.finger == 3 && k2.finger == 4) || (k1.finger == 4 && k2.finger == 3) {
            res.is_ring_pinky = true;
        }
    }

    res
}

// Helper wrappers for tests
pub fn is_sfb(i: usize, j: usize) -> bool {
    analyze_bigram(i, j).is_sfb
}
pub fn is_lateral(i: usize, j: usize) -> bool {
    analyze_bigram(i, j).is_lateral
}
pub fn is_scissor(i: usize, j: usize) -> bool {
    analyze_bigram(i, j).is_scissor
}
pub fn is_ring_pinky(i: usize, j: usize) -> bool {
    analyze_bigram(i, j).is_ring_pinky
}

keyforge/src/scorer on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat setup.rs
use super::loader::{load_cost_matrix, load_ngrams, TrigramRef};
use super::physics::get_reach_cost;
use super::Scorer;
use crate::config::{Config, KEY_DEFS, SLOTS_LOW, SLOTS_MED, SLOTS_PRIME};
use std::collections::HashSet;

pub fn build_scorer(cost_path: &str, ngrams_path: &str, config: Config, debug: bool) -> Scorer {
    if debug {
        println!(
            "\nüîß [Debug State Dump] SFB: {:.2}x | GeoWeight: {:.1} | EffortWeight: {:.1}",
            config.penalty_sfb, config.weight_geo_dist, config.weight_finger_effort
        );
    }

    let c = &config;
    let tier_penalty_matrix = [
        [0.0, c.penalty_high_in_med, c.penalty_high_in_low],
        [c.penalty_med_in_prime, 0.0, c.penalty_med_in_low],
        [c.penalty_low_in_prime, c.penalty_low_in_med, 0.0],
    ];

    let costs = load_cost_matrix(cost_path, debug);
    let mut raw_user_matrix = [[0.0; 30]; 30];
    let standard_keys = [
        "keyq",
        "keyw",
        "keye",
        "keyr",
        "keyt",
        "keyy",
        "keyu",
        "keyi",
        "keyo",
        "keyp",
        "keya",
        "keys",
        "keyd",
        "keyf",
        "keyg",
        "keyh",
        "keyj",
        "keyk",
        "keyl",
        "semicolon",
        "keyz",
        "keyx",
        "keyc",
        "keyv",
        "keyb",
        "keyn",
        "keym",
        "comma",
        "period",
        "slash",
    ];

    let mut loaded_count = 0;
    for (k1_raw, k2_raw, val) in costs.entries {
        let k1 = k1_raw.to_lowercase();
        let k2 = k2_raw.to_lowercase();
        let find = |k: &str| {
            standard_keys
                .iter()
                .position(|&sk| sk == k || sk.strip_prefix("key").unwrap_or("") == k)
        };
        if let (Some(i1), Some(i2)) = (find(&k1), find(&k2)) {
            raw_user_matrix[i1][i2] = val;
            loaded_count += 1;
        }
    }
    if loaded_count < 10 {
        for r in 0..30 {
            for col in 0..30 {
                if r != col {
                    raw_user_matrix[r][col] = config.default_cost_ms;
                }
            }
        }
    }

    let mut full_cost_matrix = raw_user_matrix;
    for i in 0..30 {
        for j in 0..30 {
            if i == j {
                continue;
            }
            let ki = &KEY_DEFS[i];
            let kj = &KEY_DEFS[j];
            if ki.hand == kj.hand {
                if ki.finger == kj.finger {
                    full_cost_matrix[i][j] *= config.penalty_sfb;
                } else if (ki.finger as i8 - kj.finger as i8).abs() == 1
                    && (ki.row - kj.row).abs() >= 2
                {
                    full_cost_matrix[i][j] *= config.penalty_scissor;
                } else if (ki.finger == 3 && kj.finger == 4) || (ki.finger == 4 && kj.finger == 3) {
                    full_cost_matrix[i][j] *= config.penalty_ring_pinky;
                } else if ki.row == kj.row && (ki.col - kj.col).abs() == 1 {
                    full_cost_matrix[i][j] *= config.penalty_lateral;
                }
            }
        }
    }

    let valid_set: HashSet<u8> = b"abcdefghijklmnopqrstuvwxyz.,/;".iter().cloned().collect();
    let raw_ngrams = load_ngrams(ngrams_path, &valid_set, config.corpus_scale, debug);

    if raw_ngrams.bigrams.is_empty() && raw_ngrams.char_freqs.iter().sum::<f32>() == 0.0 {
        panic!(
            "‚ùå FATAL: Loaded N-gram file resulted in 0 valid entries! Check delimiters/format."
        );
    }

    let mut bigram_starts = vec![0; 257];
    let mut bigrams_others = Vec::new();
    let mut bigrams_freqs = Vec::new();
    let mut bigrams_self_first = Vec::new();
    let mut b_buckets: Vec<Vec<(u8, f32, bool)>> = vec![Vec::new(); 256];
    let mut freq_matrix = [[0.0; 256]; 256];

    for (b1, b2, freq) in raw_ngrams.bigrams {
        b_buckets[b1 as usize].push((b2, freq, true));
        b_buckets[b2 as usize].push((b1, freq, false));
        freq_matrix[b1 as usize][b2 as usize] = freq;
    }
    let mut offset = 0;
    for i in 0..256 {
        bigram_starts[i] = offset;
        for (other, freq, is_first) in &b_buckets[i] {
            bigrams_others.push(*other);
            bigrams_freqs.push(*freq);
            bigrams_self_first.push(*is_first);
        }
        offset += b_buckets[i].len();
    }
    bigram_starts[256] = offset;

    let mut t_buckets: Vec<Vec<TrigramRef>> = vec![Vec::new(); 256];
    for (b1, b2, b3, freq) in raw_ngrams.trigrams {
        t_buckets[b1 as usize].push(TrigramRef {
            other1: b2,
            other2: b3,
            freq,
            role: 0,
        });
        t_buckets[b2 as usize].push(TrigramRef {
            other1: b1,
            other2: b3,
            freq,
            role: 1,
        });
        t_buckets[b3 as usize].push(TrigramRef {
            other1: b1,
            other2: b2,
            freq,
            role: 2,
        });
    }
    let mut trigram_starts = vec![0; 257];
    let mut trigrams_flat = Vec::new();
    let mut t_offset = 0;
    for i in 0..256 {
        trigram_starts[i] = t_offset;
        for t_ref in &t_buckets[i] {
            trigrams_flat.push(t_ref.clone());
        }
        t_offset += t_buckets[i].len();
    }
    trigram_starts[256] = t_offset;

    let mut trigram_cost_table = vec![0.0; 27000];
    for i in 0..30 {
        for j in 0..30 {
            for k in 0..30 {
                let idx = i * 900 + j * 30 + k;
                let ki = &KEY_DEFS[i];
                let kj = &KEY_DEFS[j];
                let kk = &KEY_DEFS[k];
                if ki.hand == kj.hand && kj.hand == kk.hand {
                    trigram_cost_table[idx] += config.penalty_hand_run;
                    let f_i = ki.finger as i8;
                    let f_j = kj.finger as i8;
                    let f_k = kk.finger as i8;
                    if f_i == f_k && f_i != f_j {
                        trigram_cost_table[idx] += config.penalty_skip;
                    }
                    let dir1 = f_j - f_i;
                    let dir2 = f_k - f_j;
                    if dir1 != 0 && dir2 != 0 && dir1.signum() != dir2.signum() {
                        trigram_cost_table[idx] += config.penalty_redirect;
                    }
                    if dir1 < 0 && dir2 < 0 {
                        trigram_cost_table[idx] -= config.bonus_inward_roll;
                    }
                }
            }
        }
    }

    let mut char_tier_map = [2u8; 256];
    for b in config.tier_high_chars.bytes() {
        char_tier_map[b as usize] = 0;
    }
    for b in config.tier_med_chars.bytes() {
        char_tier_map[b as usize] = 1;
    }
    let mut slot_tier_map = [0u8; 30];
    for &i in SLOTS_PRIME {
        slot_tier_map[i] = 0;
    }
    for &i in SLOTS_MED {
        slot_tier_map[i] = 1;
    }
    for &i in SLOTS_LOW {
        slot_tier_map[i] = 2;
    }
    let mut critical_mask = [false; 256];
    for pair in config.get_critical_bigrams() {
        critical_mask[pair[0] as usize] = true;
        critical_mask[pair[1] as usize] = true;
    }

    let finger_scales = config.get_finger_penalty_scale();

    let mut slot_monogram_costs = [0.0; 30];
    for i in 0..30 {
        let ki = &KEY_DEFS[i];
        let effort_cost = finger_scales[ki.finger as usize] * config.weight_finger_effort;
        let reach_cost = get_reach_cost(i, config.weight_geo_dist);
        slot_monogram_costs[i] = reach_cost + effort_cost;
    }

    if debug {
        println!("   ‚úÖ Scorer Initialized.\n");
    }

    Scorer {
        config,
        tier_penalty_matrix,
        full_cost_matrix,
        raw_user_matrix,
        trigram_cost_table,
        bigram_starts,
        bigrams_others,
        bigrams_freqs,
        bigrams_self_first,
        trigram_starts,
        trigrams_flat,
        char_freqs: raw_ngrams.char_freqs,
        char_tier_map,
        slot_tier_map,
        critical_mask,
        freq_matrix,
        finger_scales,
        slot_monogram_costs,
    }
}

‚ùØ cat types.rs
#[derive(Debug, Default, Clone, Copy)]
pub struct ScoreDetails {
    // Top-line Scores
    pub layout_score: f32,    
    pub user_score: f32,      

    // Raw Distance Components
    pub geo_dist: f32,        
    pub user_dist: f32,       
    
    // Effort
    pub finger_use: f32,      
    
    // Penalty Components (Pain)
    pub penalty_geo: f32,     
    pub penalty_user: f32,    
    
    // Components for Reporting
    pub geo_sfb: f32,
    pub geo_lateral: f32,
    pub geo_scissor: f32,
    
    pub user_penalty_sfb: f32,
    pub user_penalty_lat: f32, 
    pub user_penalty_scis: f32,

    // Flow
    pub flow_cost: f32,       
    pub flow_redirect: f32,
    pub flow_skip: f32,
    pub flow_run: f32,
    pub flow_roll: f32, 

    // Heuristics
    pub tier_penalty: f32,    
    pub imbalance_penalty: f32,
}‚èé                  

keyforge/src/optimizer on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat mod.rs
pub mod mutation;

use self::mutation::*;
use crate::scorer::Scorer;
use std::sync::Arc;

#[inline(always)]
fn fast_exp(x: f32) -> f32 {
    let x = 1.0 + x / 256.0;
    let x = x * x;
    let x = x * x;
    let x = x * x;
    let x = x * x;
    let x = x * x;
    let x = x * x;
    let x = x * x;
    let x = x * x;
    x
}

#[repr(align(64))]
pub struct Replica {
    pub scorer: Arc<Scorer>,
    pub local_cost_matrix: [[f32; 30]; 30],
    pub local_trigram_costs: Vec<f32>,
    pub local_monogram_costs: [f32; 30], // NEW: Local copy for speed

    pub layout: [u8; 30],
    pub pos_map: [u8; 256],
    pub score: f32,
    pub left_load: f32,
    pub total_freq: f32,
    pub temperature: f32,
    pub debug: bool,
    pub current_limit: usize,
    pub rng: fastrand::Rng,
}

impl Replica {
    pub fn new(scorer: Arc<Scorer>, temperature: f32, seed: Option<u64>, debug: bool) -> Self {
        let mut rng = if let Some(s) = seed {
            fastrand::Rng::with_seed(s)
        } else {
            fastrand::Rng::new()
        };

        let mut layout;
        let mut pos_map;
        loop {
            layout = generate_tiered_layout(&mut rng, &scorer.config);
            pos_map = build_pos_map(&layout);
            let critical = scorer.config.get_critical_bigrams();
            if !fails_sanity(&pos_map, &critical) {
                break;
            }
        }

        let start_limit = if temperature > 10.0 {
            scorer.config.opt_limit_fast
        } else {
            scorer.config.opt_limit_slow
        };
        let (base, left, total) = scorer.score_full(&pos_map, start_limit);
        let mut score = base;
        // Note: score_full already includes imbalance in my updated Scorer,
        // so we don't need to double add it if Scorer::score_full handles it.
        // Checking Scorer... Yes, score_full adds imbalance.
        // However, Replica logic below re-adds it manually in calc_delta.
        // To stay safe, let's assume base includes it.

        // IMPORTANT: In calc_delta, we often calculate delta_base separately from imbalance.
        // Let's ensure consistency.

        let local_cost_matrix = scorer.full_cost_matrix;
        let local_trigram_costs = scorer.trigram_cost_table.clone();
        let local_monogram_costs = scorer.slot_monogram_costs; // Copy

        Replica {
            scorer,
            local_cost_matrix,
            local_trigram_costs,
            local_monogram_costs,
            layout,
            pos_map,
            score,
            left_load: left,
            total_freq: total,
            temperature,
            debug,
            current_limit: start_limit,
            rng,
        }
    }

    pub fn check_integrity(&self) -> (f32, f32) {
        let (real_total, _, _) = self.scorer.score_full(&self.pos_map, self.current_limit);
        let diff = (self.score - real_total).abs();
        (diff, real_total)
    }

    #[inline(always)]
    pub fn calc_delta(&self, idx_a: usize, idx_b: usize, trigram_limit: usize) -> (f32, f32) {
        let char_a = self.layout[idx_a] as usize;
        let char_b = self.layout[idx_b] as usize;
        let mut delta_score = 0.0;

        // 1. Monogram Delta (Reach + Effort + Tier)
        // Physics (Pre-calc)
        let freq_a = self.scorer.char_freqs[char_a];
        let freq_b = self.scorer.char_freqs[char_b];

        // A goes from idx_a to idx_b.
        delta_score +=
            (self.local_monogram_costs[idx_b] - self.local_monogram_costs[idx_a]) * freq_a;
        // B goes from idx_b to idx_a.
        delta_score +=
            (self.local_monogram_costs[idx_a] - self.local_monogram_costs[idx_b]) * freq_b;

        // Tier Delta
        let tier_char_a = self.scorer.char_tier_map[char_a] as usize;
        let tier_char_b = self.scorer.char_tier_map[char_b] as usize;
        if tier_char_a < 3 && tier_char_b < 3 {
            let tier_slot_a = self.scorer.slot_tier_map[idx_a] as usize;
            let tier_slot_b = self.scorer.slot_tier_map[idx_b] as usize;
            if tier_char_a < 3 {
                delta_score -= self.scorer.tier_penalty_matrix[tier_char_a][tier_slot_a] * freq_a;
                delta_score += self.scorer.tier_penalty_matrix[tier_char_a][tier_slot_b] * freq_a;
            }
            if tier_char_b < 3 {
                delta_score -= self.scorer.tier_penalty_matrix[tier_char_b][tier_slot_b] * freq_b;
                delta_score += self.scorer.tier_penalty_matrix[tier_char_b][tier_slot_a] * freq_b;
            }
        }

        if delta_score > (self.temperature * 10.0) {
            return (f32::INFINITY, 0.0);
        }

        // 2. Bigrams
        let start_a = self.scorer.bigram_starts[char_a];
        let end_a = self.scorer.bigram_starts[char_a + 1];
        let others_a = &self.scorer.bigrams_others[start_a..end_a];
        let freqs_a = &self.scorer.bigrams_freqs[start_a..end_a];
        let self_first_a = &self.scorer.bigrams_self_first[start_a..end_a];

        for i in 0..others_a.len() {
            let other = others_a[i] as usize;
            let p_other = self.pos_map[other] as usize;
            if p_other != 255 {
                let freq = freqs_a[i];
                if self_first_a[i] {
                    delta_score -= self.local_cost_matrix[idx_a][p_other] * freq;
                    delta_score += self.local_cost_matrix[idx_b][p_other] * freq;
                } else {
                    delta_score -= self.local_cost_matrix[p_other][idx_a] * freq;
                    delta_score += self.local_cost_matrix[p_other][idx_b] * freq;
                }
            }
        }

        let start_b = self.scorer.bigram_starts[char_b];
        let end_b = self.scorer.bigram_starts[char_b + 1];
        let others_b = &self.scorer.bigrams_others[start_b..end_b];
        let freqs_b = &self.scorer.bigrams_freqs[start_b..end_b];
        let self_first_b = &self.scorer.bigrams_self_first[start_b..end_b];

        for i in 0..others_b.len() {
            let other = others_b[i] as usize;
            let p_other = self.pos_map[other] as usize;
            if p_other != 255 {
                let freq = freqs_b[i];
                if self_first_b[i] {
                    delta_score -= self.local_cost_matrix[idx_b][p_other] * freq;
                    delta_score += self.local_cost_matrix[idx_a][p_other] * freq;
                } else {
                    delta_score -= self.local_cost_matrix[p_other][idx_b] * freq;
                    delta_score += self.local_cost_matrix[p_other][idx_a] * freq;
                }
            }
        }

        let freq_ab = self.scorer.freq_matrix[char_a][char_b];
        if freq_ab > 0.0 {
            let cab = self.local_cost_matrix[idx_a][idx_b];
            let cba = self.local_cost_matrix[idx_b][idx_a];
            let caa = self.local_cost_matrix[idx_a][idx_a];
            let cbb = self.local_cost_matrix[idx_b][idx_b];
            delta_score += (cba + cab - cbb - caa) * freq_ab;
        }
        let freq_ba = self.scorer.freq_matrix[char_b][char_a];
        if freq_ba > 0.0 {
            let cba = self.local_cost_matrix[idx_b][idx_a];
            let cab = self.local_cost_matrix[idx_a][idx_b];
            let cbb = self.local_cost_matrix[idx_b][idx_b];
            let caa = self.local_cost_matrix[idx_a][idx_a];
            delta_score += (cab + cba - caa - cbb) * freq_ba;
        }
        let freq_aa = self.scorer.freq_matrix[char_a][char_a];
        if freq_aa > 0.0 {
            delta_score += (self.local_cost_matrix[idx_b][idx_b]
                - self.local_cost_matrix[idx_a][idx_a])
                * freq_aa;
        }
        let freq_bb = self.scorer.freq_matrix[char_b][char_b];
        if freq_bb > 0.0 {
            delta_score += (self.local_cost_matrix[idx_a][idx_a]
                - self.local_cost_matrix[idx_b][idx_b])
                * freq_bb;
        }

        // 3. Trigrams
        let start = self.scorer.trigram_starts[char_a];
        let end = self.scorer.trigram_starts[char_a + 1];
        let len = end - start;
        let limit = if len < trigram_limit {
            len
        } else {
            trigram_limit
        };

        for t in &self.scorer.trigrams_flat[start..(start + limit)] {
            let o1 = t.other1 as usize;
            let o2 = t.other2 as usize;
            let p1_old = self.pos_map[o1] as usize;
            let p2_old = self.pos_map[o2] as usize;

            if p1_old != 255 && p2_old != 255 {
                let p1_new = if o1 == char_b {
                    idx_a
                } else if o1 == char_a {
                    idx_b
                } else {
                    p1_old
                };
                let p2_new = if o2 == char_b {
                    idx_a
                } else if o2 == char_a {
                    idx_b
                } else {
                    p2_old
                };

                let cost_old = match t.role {
                    0 => self.local_trigram_costs[idx_a * 900 + p1_old * 30 + p2_old],
                    1 => self.local_trigram_costs[p1_old * 900 + idx_a * 30 + p2_old],
                    _ => self.local_trigram_costs[p1_old * 900 + p2_old * 30 + idx_a],
                };
                let cost_new = match t.role {
                    0 => self.local_trigram_costs[idx_b * 900 + p1_new * 30 + p2_new],
                    1 => self.local_trigram_costs[p1_new * 900 + idx_b * 30 + p2_new],
                    _ => self.local_trigram_costs[p1_new * 900 + p2_new * 30 + idx_b],
                };
                delta_score += (cost_new - cost_old) * t.freq;
            }
        }

        let start = self.scorer.trigram_starts[char_b];
        let end = self.scorer.trigram_starts[char_b + 1];
        let len = end - start;
        let limit = if len < trigram_limit {
            len
        } else {
            trigram_limit
        };

        for t in &self.scorer.trigrams_flat[start..(start + limit)] {
            let o1 = t.other1 as usize;
            let o2 = t.other2 as usize;
            if o1 == char_a || o2 == char_a {
                continue;
            }

            let p1_old = self.pos_map[o1] as usize;
            let p2_old = self.pos_map[o2] as usize;

            if p1_old != 255 && p2_old != 255 {
                let p1_new = if o1 == char_b { idx_a } else { p1_old };
                let p2_new = if o2 == char_b { idx_a } else { p2_old };

                let cost_old = match t.role {
                    0 => self.local_trigram_costs[idx_b * 900 + p1_old * 30 + p2_old],
                    1 => self.local_trigram_costs[p1_old * 900 + idx_b * 30 + p2_old],
                    _ => self.local_trigram_costs[p1_old * 900 + p2_old * 30 + idx_b],
                };
                let cost_new = match t.role {
                    0 => self.local_trigram_costs[idx_a * 900 + p1_new * 30 + p2_new],
                    1 => self.local_trigram_costs[p1_new * 900 + idx_a * 30 + p2_new],
                    _ => self.local_trigram_costs[p1_new * 900 + p2_new * 30 + idx_a],
                };
                delta_score += (cost_new - cost_old) * t.freq;
            }
        }

        // Load Balance Delta
        let mut delta_left_load = 0.0;
        let is_left_a = (idx_a % 10) < 5; // Hardcoded for standard stagger, will need Item 3 later
        let is_left_b = (idx_b % 10) < 5;
        if is_left_a && !is_left_b {
            delta_left_load -= freq_a;
            delta_left_load += freq_b;
        } else if !is_left_a && is_left_b {
            delta_left_load += freq_a;
            delta_left_load -= freq_b;
        }

        (delta_score, delta_left_load)
    }

    #[inline(always)]
    pub fn evolve(&mut self, steps: usize) -> (usize, usize) {
        let mut accepted = 0;
        let target_limit = if self.temperature > 10.0 {
            self.scorer.config.opt_limit_fast
        } else {
            self.scorer.config.opt_limit_slow
        };

        if target_limit != self.current_limit {
            self.current_limit = target_limit;
            let (new_base, _, _) = self.scorer.score_full(&self.pos_map, target_limit);
            // score_full includes imbalance, but we handle it incrementally below.
            // Best to just reset score completely.
            self.score = new_base;
        }

        for _ in 0..steps {
            let idx_a = self.rng.usize(0..30);
            let idx_b = self.rng.usize(0..30);
            if idx_a == idx_b {
                continue;
            }

            let (delta_base, delta_load) = self.calc_delta(idx_a, idx_b, self.current_limit);
            if delta_base == f32::INFINITY {
                continue;
            }

            // We need to separate base score from imbalance score to update them correctly
            // Or just recalc total.
            // Current strategy: self.score is TOTAL (Base + Imbalance).
            // We need to remove old imbalance, add delta_base, add new imbalance.

            // Recover old base
            let old_imbalance_pen = self.imbalance_penalty(self.left_load);
            let old_base = self.score - old_imbalance_pen;

            let new_base = old_base + delta_base;
            let new_left_load = self.left_load + delta_load;
            let new_imbalance_pen = self.imbalance_penalty(new_left_load);

            let new_total = new_base + new_imbalance_pen;
            let total_delta = new_total - self.score;

            if total_delta < 0.0 || self.rng.f32() < fast_exp(-total_delta / self.temperature) {
                self.layout.swap(idx_a, idx_b);
                let char_a = self.layout[idx_a];
                let char_b = self.layout[idx_b];
                self.pos_map[char_a as usize] = idx_a as u8;
                self.pos_map[char_b as usize] = idx_b as u8;

                let critical = self.scorer.config.get_critical_bigrams();
                let is_risky = self.scorer.critical_mask[char_a as usize]
                    || self.scorer.critical_mask[char_b as usize];

                if is_risky && fails_sanity(&self.pos_map, &critical) {
                    self.layout.swap(idx_a, idx_b);
                    self.pos_map[char_a as usize] = idx_b as u8;
                    self.pos_map[char_b as usize] = idx_a as u8;
                } else {
                    self.score = new_total;
                    self.left_load = new_left_load;
                    accepted += 1;
                }
            }
        }
        (accepted, steps)
    }

    #[inline(always)]
    fn imbalance_penalty(&self, left: f32) -> f32 {
        if self.total_freq > 0.0 {
            let ratio = left / self.total_freq;
            let dist = (ratio - 0.5).abs();
            if dist > (self.scorer.config.max_hand_imbalance - 0.5) {
                return dist * self.scorer.config.penalty_imbalance;
            }
        }
        0.0
    }
}

keyforge/src/optimizer on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat mutation.rs
use crate::config::{Config, KEY_DEFS, SLOTS_LOW, SLOTS_MED, SLOTS_PRIME};
use fastrand::Rng;

/// Generates a random layout respecting the tier definition in Config
pub fn generate_tiered_layout(rng: &mut Rng, config: &Config) -> [u8; 30] {
    let mut layout = [0u8; 30];

    // Convert configuration strings to byte vectors for shuffling
    let mut high = config.tier_high_chars.as_bytes().to_vec();
    let mut med = config.tier_med_chars.as_bytes().to_vec();
    let mut low = config.tier_low_chars.as_bytes().to_vec();

    rng.shuffle(&mut high);
    rng.shuffle(&mut med);
    rng.shuffle(&mut low);

    // 1. Fill Prime Slots (Top Priority)
    for &slot in SLOTS_PRIME {
        if !high.is_empty() {
            layout[slot] = high.pop().unwrap();
        } else if !med.is_empty() {
            layout[slot] = med.pop().unwrap();
        }
    }

    // 2. Fill Medium Slots
    for &slot in SLOTS_MED {
        // Only fill if not already taken by a high char (if high overflowed)
        if layout[slot] == 0 {
            if !med.is_empty() {
                layout[slot] = med.pop().unwrap();
            } else if !low.is_empty() {
                layout[slot] = low.pop().unwrap();
            }
        }
    }

    // 3. Fill Low Slots
    for &slot in SLOTS_LOW {
        if layout[slot] == 0 {
            if !low.is_empty() {
                layout[slot] = low.pop().unwrap();
            } else if !med.is_empty() {
                layout[slot] = med.pop().unwrap();
            } else if !high.is_empty() {
                layout[slot] = high.pop().unwrap();
            }
        }
    }
    layout
}

pub fn build_pos_map(layout: &[u8; 30]) -> [u8; 256] {
    let mut map = [255u8; 256];
    for (i, &byte) in layout.iter().enumerate() {
        map[byte as usize] = i as u8;
    }
    map
}

/// Checks if the layout violates critical bigram constraints (SFBs on critical pairs)
pub fn fails_sanity(pos_map: &[u8; 256], critical_bigrams: &[[u8; 2]]) -> bool {
    for pair in critical_bigrams {
        let p1 = pos_map[pair[0] as usize];
        let p2 = pos_map[pair[1] as usize];

        // Skip if one char isn't in the layout (shouldn't happen in search, but safe)
        if p1 == 255 || p2 == 255 {
            continue;
        }

        let info1 = &KEY_DEFS[p1 as usize];
        let info2 = &KEY_DEFS[p2 as usize];

        // Sanity Check: Same hand, same finger = SFB (Bad for critical pairs)
        if info1.hand == info2.hand && info1.finger == info2.finger {
            return true;
        }
    }
    false
}

keyforge/tests on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ ls
cli_tests.rs    loader_tests.rs  poison_pill.rs
config_test.rs  physics_tests.rs       reproducibility.rs

keyforge/tests on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat cli_tests.rs 
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::process::Command;
use tempfile::TempDir;

struct TestContext {
    _dir: TempDir,
    cost_path: PathBuf,
    ngram_path: PathBuf,
}

impl TestContext {
    fn new() -> Self {
        let dir = tempfile::tempdir().expect("Failed to create temp dir");
        let cost_path = dir.path().join("test_cost.csv");
        let ngram_path = dir.path().join("test_ngrams.tsv");

        // 1. Create Cost Matrix
        let mut cost_file = File::create(&cost_path).unwrap();
        writeln!(cost_file, "From,To,Cost").unwrap();
        writeln!(cost_file, "KeyQ,KeyA,10.0").unwrap();
        writeln!(cost_file, "KeyW,KeyE,10.0").unwrap();

        let filler_keys = [
            "KeyR", "KeyT", "KeyY", "KeyU", "KeyI", "KeyO", "KeyP", "KeyS",
        ];
        for k in filler_keys {
            writeln!(cost_file, "KeyQ,{},10.0", k).unwrap();
        }

        // 2. Create N-Grams
        let mut ngram_file = File::create(&ngram_path).unwrap();

        // Bigrams (Distance/SFB/Lateral)
        writeln!(ngram_file, "qa\t1000").unwrap();
        writeln!(ngram_file, "we\t1000").unwrap();

        // Trigrams (Flow metrics)
        // "asd" on Qwerty: Left Pinky(A) -> Ring(S) -> Middle(D).
        // Fingers 4->3->2. This is an INWARD ROLL.
        writeln!(ngram_file, "asd\t1000").unwrap();

        // "sad" on Qwerty: Ring(S) -> Pinky(A) -> Middle(D).
        // Fingers 3->4 (Out), 4->2 (In). This is a REDIRECT.
        writeln!(ngram_file, "sad\t1000").unwrap();

        // Monograms (Tier penalties)
        writeln!(ngram_file, "a\t1000").unwrap();
        writeln!(ngram_file, "s\t1000").unwrap();
        writeln!(ngram_file, "d\t1000").unwrap();
        writeln!(ngram_file, "q\t100").unwrap();
        writeln!(ngram_file, "w\t100").unwrap();
        writeln!(ngram_file, "e\t1000").unwrap();

        Self {
            _dir: dir,
            cost_path,
            ngram_path,
        }
    }
}

struct TestResult {
    total: f32,
    tier: f32,
    redir: f32,
    roll: f32,
    stdout: String,
}

fn run_validate(ctx: &TestContext, args: &[&str]) -> TestResult {
    let mut final_args = vec![
        "validate",
        "--layout",
        "qwerty",
        "--debug",
        "--cost",
        ctx.cost_path.to_str().unwrap(),
        "--ngrams",
        ctx.ngram_path.to_str().unwrap(),
    ];

    // Smart default: only add corpus-scale if not provided in args
    if !args.contains(&"--corpus-scale") {
        final_args.push("--corpus-scale");
        final_args.push("1.0");
    }

    final_args.extend_from_slice(args);

    let output = Command::new("./target/release/keyforge")
        .args(&final_args)
        .output()
        .expect("Failed to execute keyforge binary");

    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();

    if !output.status.success() {
        panic!(
            "KeyForge Crashed!\nARGS: {:?}\nSTDERR:\n{}\nSTDOUT:\n{}",
            final_args, stderr, stdout
        );
    }

    let mut total = 0.0;
    let mut tier = 0.0;
    let mut redir = 0.0;
    let mut roll = 0.0;

    // Parse VALIDATION REPORT table
    // Format: Layout | Total | Dist | Finger | SFB Lat Scis | Redir Skip Roll | Tier | Bal
    // Pipe Indices:
    // 0: Name
    // 1: Total
    // 2: Dist
    // 3: Effort
    // 4: Pain Group ("5000 100 0")
    // 5: Flow Group ("0 0 0")
    // 6: Tier
    // 7: Bal

    for line in stdout.lines() {
        if line.contains("qwerty") {
            let parts: Vec<&str> = line.split('|').collect();

            if parts.len() > 1 {
                total = parts[1].trim().parse().unwrap_or(0.0);
            }

            // Parse Flow Group (Index 5)
            if parts.len() > 5 {
                let flow_str = parts[5].trim();
                let flow_nums: Vec<&str> = flow_str.split_whitespace().collect();
                if flow_nums.len() >= 3 {
                    redir = flow_nums[0].parse().unwrap_or(0.0);
                    roll = flow_nums[2].parse().unwrap_or(0.0);
                }
            }

            if parts.len() > 6 {
                tier = parts[6].trim().parse().unwrap_or(0.0);
            }
        }
    }

    TestResult {
        total,
        tier,
        redir,
        roll,
        stdout,
    }
}

#[test]
fn test_sanity_check_ranking() {
    let _ = Command::new("cargo")
        .arg("build")
        .arg("--release")
        .status()
        .unwrap();
    let ctx = TestContext::new();
    let res = run_validate(&ctx, &[]);
    assert!(res.total > 0.0);
}

#[test]
fn test_cli_biomechanical_penalties() {
    let _ = Command::new("cargo")
        .arg("build")
        .arg("--release")
        .status()
        .unwrap();
    let ctx = TestContext::new();

    let res_base = run_validate(&ctx, &[]);
    assert!(res_base.total > 0.0, "Baseline score is zero");

    // SFB Penalty
    let res_sfb = run_validate(&ctx, &["--penalty-sfb", "50.0"]);
    if res_sfb.total <= res_base.total * 1.1 {
        println!("DEBUG LOG:\n{}", res_sfb.stdout);
        panic!("SFB Penalty failed to apply to Total Score");
    }
}

#[test]
fn test_cli_tier_configuration() {
    let _ = Command::new("cargo")
        .arg("build")
        .arg("--release")
        .status()
        .unwrap();
    let ctx = TestContext::new();

    // Setup: Make High-in-Med expensive
    let args_expensive = [
        "--penalty-high-in-med",
        "100.0",
        "--penalty-low-in-med",
        "0.0",
    ];
    let res_base = run_validate(&ctx, &args_expensive);

    // Action: Change 'E' to Low Tier.
    // 'E' is on Top Row (Med Slot).
    // High->Low transition in Med Slot should reduce penalty.
    let mut args_cheap = vec!["--tier-high-chars", "z"];
    args_cheap.extend_from_slice(&args_expensive);

    let res_mod = run_validate(&ctx, &args_cheap);

    println!("Base Tier: {}, Mod Tier: {}", res_base.tier, res_mod.tier);

    if res_mod.tier >= res_base.tier {
        println!("STDOUT:\n{}", res_mod.stdout);
        panic!("Tier config change failed to reduce Tier score");
    }
}

#[test]
fn test_cli_flow_metrics() {
    let _ = Command::new("cargo")
        .arg("build")
        .arg("--release")
        .status()
        .unwrap();
    let ctx = TestContext::new();

    // Default config has flow penalties active
    let res = run_validate(&ctx, &[]);

    println!("Redir: {}, Roll: {}", res.redir, res.roll);

    if res.redir == 0.0 {
        println!("STDOUT:\n{}", res.stdout);
        panic!("Flow Logic Failure: Redirects (sad) not detected");
    }
    if res.roll == 0.0 {
        println!("STDOUT:\n{}", res.stdout);
        panic!("Flow Logic Failure: Rolls (asd) not detected");
    }
}

#[test]
fn test_cli_corpus_scaling() {
    let _ = Command::new("cargo")
        .arg("build")
        .arg("--release")
        .status()
        .unwrap();
    let ctx = TestContext::new();

    let res_small = run_validate(&ctx, &["--corpus-scale", "1000.0"]);
    let res_big = run_validate(&ctx, &["--corpus-scale", "1.0"]);

    if res_big.total <= res_small.total * 100.0 {
        panic!("Corpus scaling factor failed");
    }
}

#[test]
fn test_cli_search_execution() {
    let _ = Command::new("cargo")
        .arg("build")
        .arg("--release")
        .status()
        .unwrap();
    let ctx = TestContext::new();

    let output = Command::new("./target/release/keyforge")
        .args(&[
            "search",
            "--debug",
            "--cost",
            ctx.cost_path.to_str().unwrap(),
            "--ngrams",
            ctx.ngram_path.to_str().unwrap(),
            "--corpus-scale",
            "1.0",
            "--search-epochs",
            "1",
            "--search-steps",
            "10",
            "--attempts",
            "1",
        ])
        .output()
        .expect("Failed to run search");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(output.status.success());
    assert!(stdout.contains("Attempt #1"));
}

keyforge/tests on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat loader_tests.rs 

use keyforge::scorer::loader::{load_cost_matrix, load_ngrams};
use std::collections::HashSet;
use std::io::Write;
use tempfile::NamedTempFile;

fn get_valid_chars() -> HashSet<u8> {
    b"abcdefghijklmnopqrstuvwxyz.,/;".iter().cloned().collect()
}

// --- N-GRAM LOAD TESTS ---

#[test]
fn test_loader_parses_valid_ngrams() {
    let mut file = NamedTempFile::new().unwrap();
    writeln!(file, "a\t100").unwrap();
    writeln!(file, "th\t200").unwrap();
    writeln!(file, "the\t300").unwrap();

    let valid = get_valid_chars();
    let raw = load_ngrams(file.path().to_str().unwrap(), &valid, 1.0, true);

    assert_eq!(raw.char_freqs[b'a' as usize], 100.0);
    assert_eq!(raw.bigrams.len(), 1);
    assert_eq!(raw.trigrams.len(), 1);
}

#[test]
fn test_loader_handles_complex_tsv() {
    // Simulation of your ngrams-all.tsv structure
    let mut file = NamedTempFile::new().unwrap();
    writeln!(file, "-gram\t*/*\t1/*\t...").unwrap(); // Header 1
    writeln!(file, "E\t100\t...").unwrap(); // Monogram
    writeln!(file, "2-gram\t*/*\t2/*\t...").unwrap(); // Header 2
    writeln!(file, "TH\t200\t...").unwrap(); // Bigram
    writeln!(file, "3-gram\t*/*\t3/*\t...").unwrap(); // Header 3
    writeln!(file, "THE\t300\t...").unwrap(); // Trigram

    let valid = get_valid_chars();
    let raw = load_ngrams(file.path().to_str().unwrap(), &valid, 1.0, true);

    // Should skip headers (invalid chars '*' or '-')
    // Should match E, TH, THE
    assert_eq!(raw.char_freqs[b'e' as usize], 100.0);
    assert_eq!(raw.bigrams.len(), 1);
    assert_eq!(raw.bigrams[0].0, b't');
    assert_eq!(raw.bigrams[0].1, b'h');
    assert_eq!(raw.trigrams.len(), 1);
}

#[test]
fn test_loader_handles_case_insensitivity() {
    let mut file = NamedTempFile::new().unwrap();
    writeln!(file, "TH\t100").unwrap();
    let valid = get_valid_chars();
    let raw = load_ngrams(file.path().to_str().unwrap(), &valid, 1.0, true);
    assert_eq!(raw.bigrams.len(), 1);
    assert_eq!(raw.bigrams[0].0, b't');
}

#[test]
fn test_loader_skips_invalid_chars() {
    let mut file = NamedTempFile::new().unwrap();
    writeln!(file, "q$\t100").unwrap();
    let valid = get_valid_chars();
    let raw = load_ngrams(file.path().to_str().unwrap(), &valid, 1.0, true);
    assert_eq!(raw.bigrams.len(), 0);
}

// --- COST MATRIX LOAD TESTS ---

#[test]
fn test_loader_parses_cost_matrix() {
    let mut file = NamedTempFile::new().unwrap();
    writeln!(file, "From,To,Cost").unwrap();
    writeln!(file, "KeyQ,KeyW,1.5").unwrap();
    let raw = load_cost_matrix(file.path().to_str().unwrap(), true);
    assert_eq!(raw.entries.len(), 1);
    assert_eq!(raw.entries[0].2, 1.5);
}

#[test]
fn test_loader_cost_matrix_handles_whitespace() {
    let mut file = NamedTempFile::new().unwrap();
    writeln!(file, "From,To,Cost").unwrap();
    writeln!(file, "KeyQ , KeyW , 1.5").unwrap(); // Spaces!
    let raw = load_cost_matrix(file.path().to_str().unwrap(), true);
    assert_eq!(raw.entries.len(), 1);
    assert_eq!(raw.entries[0].2, 1.5);
}

#[test]
fn test_loader_cost_matrix_skips_bad_lines() {
    let mut file = NamedTempFile::new().unwrap();
    writeln!(file, "From,To,Cost").unwrap();
    writeln!(file, "KeyQ,KeyW,1.5").unwrap(); // Good
    writeln!(file, "Garbage").unwrap(); // Bad
    let raw = load_cost_matrix(file.path().to_str().unwrap(), true);
    assert_eq!(raw.entries.len(), 1);
}

keyforge/tests on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat physics_tests.rs

use keyforge::scorer::physics::{get_reach_cost, is_lateral, is_scissor, is_sfb};
use rstest::rstest;

// --- KEY INDEX MAPPING (Standard 30-key Grid) ---
// Row 0 (Top)
const Q: usize = 0; // L Pinky
const W: usize = 1; // L Ring
const E: usize = 2; // L Middle
const R: usize = 3; // L Index
const T: usize = 4; // L Index (Stretch)

// Row 1 (Home)
const A: usize = 10; // L Pinky
const S: usize = 11; // L Ring
const D: usize = 12; // L Middle
const F: usize = 13; // L Index
const G: usize = 14; // L Index (Stretch)
const H: usize = 15; // R Index (Stretch)

// Row 2 (Bottom)
const Z: usize = 20; // L Pinky
const C: usize = 22; // L Middle
const V: usize = 23; // L Index

// --- SFB TESTS ---
// Definition: Same Hand, Same Finger, Different Key.1
#[rstest]
#[case(Q, A, true)] // Pinky Top -> Pinky Home
#[case(F, R, true)] // Index Home -> Index Top
#[case(F, T, true)] // Index Home -> Index Stretch
#[case(F, V, true)] // Index Home -> Index Bottom
#[case(F, G, true)] // Index Home -> Index Stretch (Same Finger = SFB)
#[case(W, E, false)] // Ring -> Middle (Different fingers)
#[case(A, S, false)] // Pinky -> Ring
fn test_is_sfb(#[case] k1: usize, #[case] k2: usize, #[case] expected: bool) {
    assert_eq!(
        is_sfb(k1, k2),
        expected,
        "SFB check failed for keys {} -> {}",
        k1,
        k2
    );
}

// --- LATERAL TESTS ---
// Definition: Same Row, Adjacent Columns, Involving Stretch column.
#[rstest]
// 1. The "Good" Neighbors (No Penalty)
#[case(W, E, false)] // Ring -> Middle
#[case(S, D, false)] // Ring -> Middle
#[case(D, F, false)] // Middle -> Index

// 2. The "Stretch" Neighbors (Lateral Penalty)
#[case(F, G, true)] // Index -> Index Stretch (IS Lateral)
#[case(R, T, true)] // Index -> Index Stretch (IS Lateral)
#[case(H, G, false)] // Right Index -> Left Index (Cross hand = False)
#[case(A, S, false)] // Pinky -> Ring (Neighbors)
fn test_is_lateral(#[case] k1: usize, #[case] k2: usize, #[case] expected: bool) {
    assert_eq!(
        is_lateral(k1, k2),
        expected,
        "Lateral check failed for keys {} -> {}",
        k1,
        k2
    );
}

// --- SCISSOR TESTS ---
// Definition: Adjacent Fingers, Row Difference >= 2.
#[rstest]
// 1. True Scissors
#[case(R, C, true)] // Top Index (3) -> Bot Middle (22). Row Diff 2. Finger Diff 1.
#[case(W, Z, true)] // Top Ring (1) -> Bot Pinky (20). Row Diff 2. Finger Diff 1.
#[case(E, V, true)] // Top Middle -> Bot Index.

// 2. Not Scissors
#[case(R, D, false)] // Top -> Home (Row Diff 1)
#[case(F, C, false)] // Home -> Bottom (Row Diff 1)
#[case(Q, Z, false)] // Pinky -> Pinky (SFB, not Scissor)
#[case(R, Z, false)] // Index -> Pinky (Finger diff > 1)
fn test_is_scissor(#[case] k1: usize, #[case] k2: usize, #[case] expected: bool) {
    assert_eq!(
        is_scissor(k1, k2),
        expected,
        "Scissor check failed for keys {} -> {}",
        k1,
        k2
    );
}

// --- REACH COST TESTS ---
#[rstest]
#[case(A, 0.0)] // Home Row -> 0
#[case(Q, 10.0)] // Top Row -> 1.0 * 10
#[case(Z, 10.0)] // Bot Row -> 1.0 * 10
#[case(G, 10.0)] // Home Stretch -> 1.0 * 10
#[case(T, 14.142)] // Top Stretch -> Sqrt(2) * 10
fn test_reach_costs(#[case] k: usize, #[case] expected: f32) {
    let scale = 10.0;
    let cost = get_reach_cost(k, scale);
    assert!(
        (cost - expected).abs() < 0.01,
        "Reach cost for key {} was {}, expected {}",
        k,
        cost,
        expected
    );
}


keyforge/tests on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat config_test.rs 

use keyforge::config::Config;

// Helper to create a default config for testing without relying on Clap parsing
fn get_default_test_config() -> Config {
    Config {
        search_epochs: 1,
        search_steps: 1,
        search_patience: 1,
        search_patience_threshold: 0.1,
        temp_min: 0.1,
        temp_max: 1.0,
        opt_limit_fast: 100,
        opt_limit_slow: 100,
        penalty_sfb: 1.0,
        penalty_scissor: 1.0,
        penalty_ring_pinky: 1.0,
        penalty_skip: 1.0,
        penalty_redirect: 1.0,
        penalty_lateral: 1.0,
        penalty_hand_run: 1.0,
        penalty_imbalance: 1.0,
        max_hand_imbalance: 0.55,
        bonus_inward_roll: 0.0,
        penalty_high_in_med: 1.0,
        penalty_high_in_low: 1.0,
        penalty_med_in_prime: 1.0,
        penalty_med_in_low: 1.0,
        penalty_low_in_prime: 1.0,
        penalty_low_in_med: 1.0,
        tier_high_chars: "etaoinshr".to_string(),
        tier_med_chars: "ldcumwfgypb.,".to_string(),
        tier_low_chars: "vkjxqz/;".to_string(),
        critical_bigrams: "th,he".to_string(),
        finger_penalty_scale: "0.0,1.0,1.1,1.3,1.6".to_string(), // Default
        finger_repeat_scale: "1.0,1.0,1.0,1.2,1.5".to_string(),  // Default
        corpus_scale: 1.0,
        default_cost_ms: 0.0,
        weight_geo_dist: 10.0,
        weight_finger_effort: 45.0,
    }
}

#[test]
fn test_finger_penalty_parsing_defaults() {
    let config = get_default_test_config();
    // Should match default string "0.0,1.0,1.1,1.3,1.6"
    let expected = [0.0, 1.0, 1.1, 1.3, 1.6];
    let result = config.get_finger_penalty_scale();

    assert_eq!(result, expected, "Failed to parse default finger penalties");
}

#[test]
fn test_finger_penalty_parsing_custom() {
    let mut config = get_default_test_config();
    // User provides a flat profile
    config.finger_penalty_scale = "1.0,1.0,1.0,1.0,1.0".to_string();

    let expected = [1.0, 1.0, 1.0, 1.0, 1.0];
    let result = config.get_finger_penalty_scale();

    assert_eq!(result, expected, "Failed to parse custom finger penalties");
}

#[test]
#[should_panic(expected = "requires 5 values")] // FIX: Matches "requires 5 values" from src/config.rs
fn test_finger_penalty_parsing_partial_panics() {
    let mut config = get_default_test_config();
    // User only provides 3 values instead of 5
    config.finger_penalty_scale = "5.0, 5.0, 5.0".to_string();

    // This should panic now (Fail Fast)
    config.get_finger_penalty_scale();
}

#[test]
#[should_panic(expected = "Invalid number")]
fn test_finger_penalty_parsing_garbage_panics() {
    let mut config = get_default_test_config();
    // User provides bad data
    config.finger_penalty_scale = "bad, data, here, 1.0, 1.0".to_string();

    config.get_finger_penalty_scale();
}

#[test]
fn test_critical_bigram_parsing() {
    let mut config = get_default_test_config();
    config.critical_bigrams = "th, he, in".to_string();

    let result = config.get_critical_bigrams();

    assert_eq!(result.len(), 3);
    assert_eq!(result[0], [b't', b'h']);
    assert_eq!(result[1], [b'h', b'e']);
    assert_eq!(result[2], [b'i', b'n']);
}

#[test]
#[should_panic(expected = "is not 2 chars")]
fn test_critical_bigram_parsing_invalid_panics() {
    let mut config = get_default_test_config();
    // "abc" is length 3 (invalid), "t" is length 1 (invalid)
    config.critical_bigrams = "th, abc, t, he".to_string();

    config.get_critical_bigrams();
}


keyforge/tests on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat reproducibility.rs

use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::process::Command;
use tempfile::TempDir;

struct TestContext {
    _dir: TempDir,
    cost_path: PathBuf,
    ngram_path: PathBuf,
}

impl TestContext {
    fn new() -> Self {
        let dir = tempfile::tempdir().expect("Failed to create temp dir");
        let cost_path = dir.path().join("repo_cost.csv");
        let ngram_path = dir.path().join("repo_ngrams.tsv");

        // Minimal Cost Matrix
        let mut cost_file = File::create(&cost_path).unwrap();
        writeln!(cost_file, "From,To,Cost").unwrap();
        // Just need header and maybe one entry to satisfy loader,
        // or rely on default if sparse.
        writeln!(cost_file, "KeyQ,KeyW,1.0").unwrap();

        // Minimal N-Grams
        let mut ngram_file = File::create(&ngram_path).unwrap();
        writeln!(ngram_file, "the\t1000").unwrap();
        writeln!(ngram_file, "and\t500").unwrap();

        Self {
            _dir: dir,
            cost_path,
            ngram_path,
        }
    }
}

fn extract_score(output: &str) -> String {
    for line in output.lines() {
        if line.starts_with("Score:") {
            return line.to_string();
        }
    }
    "NOT_FOUND".to_string()
}

#[test]
fn test_deterministic_output() {
    let _ = Command::new("cargo")
        .arg("build")
        .arg("--release")
        .status()
        .unwrap();
    let ctx = TestContext::new();
    let bin = "./target/release/keyforge";

    // Shared args
    let args = [
        "search",
        "--seed",
        "12345",
        "--search-epochs",
        "5",
        "--attempts",
        "1",
        "--cost",
        ctx.cost_path.to_str().unwrap(),
        "--ngrams",
        ctx.ngram_path.to_str().unwrap(),
        "--corpus-scale",
        "1.0",
    ];

    // Run A
    let output_a = Command::new(bin)
        .args(&args)
        .output()
        .expect("Run A failed");
    // Run B
    let output_b = Command::new(bin)
        .args(&args)
        .output()
        .expect("Run B failed");

    let stdout_a = String::from_utf8_lossy(&output_a.stdout);
    let stdout_b = String::from_utf8_lossy(&output_b.stdout);

    let score_a = extract_score(&stdout_a);
    let score_b = extract_score(&stdout_b);

    if score_a != score_b {
        println!("--- RUN A ---\n{}", stdout_a);
        println!("--- RUN B ---\n{}", stdout_b);
    }

    assert_eq!(score_a, score_b, "Determinism check failed");
    assert_ne!(score_a, "NOT_FOUND", "Failed to parse score from output");
}

keyforge/tests on ÓÇ† master [?] via ü¶Ä v1.85.0 
‚ùØ cat poison_pill.rs 
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::process::Command;
use tempfile::TempDir;

struct TestContext {
    _dir: TempDir,
    cost_path: PathBuf,
    ngram_path: PathBuf,
}

impl TestContext {
    fn new() -> Self {
        let dir = tempfile::tempdir().expect("Failed to create temp dir");
        let cost_path = dir.path().join("poison_cost.csv");
        let ngram_path = dir.path().join("poison_ngrams.tsv");

        // 1. Poisoned Cost Matrix
        // We assign a cost of 10,000.0 to any bigram involving the Home Row (indices 10-19).
        // Standard cost is 1.0.
        let mut cost_file = File::create(&cost_path).unwrap();
        writeln!(cost_file, "From_Key,To_Key,Cost").unwrap();

        let keys = [
            "KeyQ",
            "KeyW",
            "KeyE",
            "KeyR",
            "KeyT",
            "KeyY",
            "KeyU",
            "KeyI",
            "KeyO",
            "KeyP",
            "KeyA",
            "KeyS",
            "KeyD",
            "KeyF",
            "KeyG",
            "KeyH",
            "KeyJ",
            "KeyK",
            "KeyL",
            "Semicolon",
            "KeyZ",
            "KeyX",
            "KeyC",
            "KeyV",
            "KeyB",
            "KeyN",
            "KeyM",
            "Comma",
            "Period",
            "Slash",
        ];

        for (i, k1) in keys.iter().enumerate() {
            for (j, k2) in keys.iter().enumerate() {
                if i == j {
                    continue;
                }
                let mut cost = 1.0;
                // Poison Home Row indices (10 through 19)
                if (10..=19).contains(&i) || (10..=19).contains(&j) {
                    cost = 10000.0;
                }
                writeln!(cost_file, "{},{},{}", k1, k2, cost).unwrap();
            }
        }

        // 2. N-Grams
        // We create strong connections for 'e' so moving it matters significantly.
        // We assume 'e' will try to go to Home Row via Tier Heuristics,
        // but the Cost Matrix penalty (10,000 * freq) should force it out.
        let mut ngram_file = File::create(&ngram_path).unwrap();

        // Monogram for Tier sorting
        writeln!(ngram_file, "e\t10000").unwrap();

        // Bigrams for Cost Matrix calculation
        let common = ["t", "a", "o", "i", "n", "s", "r"];
        for c in common {
            writeln!(ngram_file, "e{}\t10000", c).unwrap();
            writeln!(ngram_file, "{}e\t10000", c).unwrap();
        }

        Self {
            _dir: dir,
            cost_path,
            ngram_path,
        }
    }
}

#[test]
fn test_poison_pill_constraint() {
    // 1. Build
    let status = Command::new("cargo")
        .arg("build")
        .arg("--release")
        .status()
        .unwrap();
    assert!(status.success());

    let ctx = TestContext::new();

    // 2. Run Search
    // - Use --corpus-scale 1.0 so the 10,000 frequency is treated as raw events.
    // - 10,000 events * 10,000 cost = 100,000,000 penalty per bigram.
    // - This should easily overpower any Tier preference for the home row.
    // - Increase epochs/steps to ensure convergence.
    let output = Command::new("./target/release/keyforge")
        .args(&[
            "search",
            "--cost",
            ctx.cost_path.to_str().unwrap(),
            "--ngrams",
            ctx.ngram_path.to_str().unwrap(),
            "--corpus-scale",
            "1.0",
            "--search-epochs",
            "50",
            "--search-steps",
            "2000",
            "--attempts",
            "1",
            "--seed",
            "999",
            "--debug",
        ])
        .output()
        .expect("Failed to run search");

    let stdout = String::from_utf8_lossy(&output.stdout);

    if !output.status.success() {
        println!("STDERR:\n{}", String::from_utf8_lossy(&output.stderr));
        panic!("Keyforge binary crashed");
    }

    // 3. Parse Result to find the Layout string
    let mut layout = "";
    for line in stdout.lines() {
        if line.starts_with("Layout:") {
            layout = line.split_once(": ").unwrap().1.trim();
            break;
        }
    }

    if layout.len() != 30 {
        println!("STDOUT:\n{}", stdout);
        panic!("Invalid layout output or layout not found in stdout");
    }

    // 4. Assert 'e' is evicted from Home Row (indices 10-19)
    // The home row is poisoned; 'e' must be in Top (0-9) or Bottom (20-29)
    let home_row = &layout[10..20];

    if home_row.contains('e') {
        println!("STDOUT:\n{}", stdout);
        panic!(
            "Poison pill failed! 'e' found in poisoned home row: '{}'. Layout: {}",
            home_row, layout
        );
    }
}




